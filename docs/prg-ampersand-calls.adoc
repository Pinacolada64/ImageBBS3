:experimental: // enable kbd:[] macro

:toclevel: 5
:toc:

### `&` Routines

`&` is the command character which is BASIC's interface to 70 machine language routines of Image BBS.

====
NOTE: This section is undergoing discovery of what some routines are for and how they are used.
====

#### `&`: Image BBS Output

In BASIC, the `print` keyword (or its abbreviation, `?`) displays text on the screen, as in:

 print"Hello there!"

You can substitute `&` in Image BBS to do the same thing:

 &"Hello there!"

But unlike BASIC, after outputting this text, the cursor remains on the same line--there is no automatic carriage return printed.

It's as if a semicolon (`;`) was used after the `print` statement above--this keeps the text all on one line:

 print"Hello ";"there!";

vs. printing on two lines:

 print"Hello"
 print"there!"

To work around this, you can output a _carriage return_, which moves the cursor to the next line.

====
.Boring Background: CR/LF, CR, LF?
On other terminals or operating systems, a carriage return moves the cursor down a row, staying in the current column, but an additional _linefeed_ character is needed to move the cursor to the beginning of the current row.

 Hello 
       there!

This stairstep-looking result is what printing looks like with only a linefeed when the terminal needed both a carriage reeturn and a linefeed.
Probably not the desired result.
However, ``print``ing in Commodore BASIC--and our BBS in this example--doesn't need them.
====

 &"Hello there!"+chr$(13)

`chr$()` (read it as "`character string`") is a function that outputs a character supplied in parentheses.
A carriage return is `chr$(13)`.
So this snippet of code will move the cursor to the next line after outputting `Hello there!`.

There is also a string variable defined in `im`: `r$=chr$(13)` (short for "`return`").
This is a handy shortcut.
You can now code:

 &"Hello there!"+r$

// TODO: data file tutorial

TIP: Using the `r$` variable is actually an easy way to write data containing carriage returns to a SEQ file, as you'll see later.

But there's something even handier available.

#### Encoded Function Keys

Some special characters are difficult (or impossible) to type in BASIC.
Or, they might cause problems while reading disk files.
Therefore, they have been encoded using the reverse video letters seen while typing function keys when in Commodore's "`quote mode.`"

### BASIC Editing Modes

.Quote Mode
In the BASIC editor, once the quote mark (kbd:[Shift+2], kbd:["]) is typed, the cursor controls stop operating and start displaying reversed characters which stand for the cursor control or symbol you are hitting.
This allows your program to perform these cursor controls, because once the text inside the quotes is ``PRINT``ed they perform their functions as if typed manually.
The kbd:[Inst/Del] key is the only cursor control not affected by "`quote mode.`"

Typing a second kbd:["] exits quote mode, and allows you to use the cursor keys to edit the program line again.

TIP: See <<position-cursor>> for how to position the terminal cursor easily in Image BBS.

.Insert Mode
Insert mode is similar to quote mode, only for the number of spaces you insert with the kbd:[Shift+Inst/Del] key, the BASIC editor is in quote mode.
Once that number of characters is typed, insert mode is exited.

====
TIP: kbd:[Return] gets out of quote and insert mode, and adds the current line into the BASIC program.

kbd:[Shift+Return] gets out of quote and insert mode, but does _not_ add the current line into the BASIC program.
====

Image BBS translates specific PETSCII characters into the reverse video letters seen when typing function keys inside quotation marks.

This eliminates a few difficulties:

* Entering special characters is made easier

* Some more simply written code (and BASIC itself) can truncate data when a `,` is encountered in a SEQ file

.BASIC Pitfall
[code]
====
Using `input#2,a$` when the disk file contains a string `hello,there` returns only `hello` in `a$`.

You can prefix the string with `"` on disk to get around that.
But most likely, you want to read `hello` and `there` into two separate variables. `input#2,a$,b$` does that, resulting in `a$="hello"` and `b$="there"`.
====

////

====
This is an example
======
This is an example inside an example
======
====

////

Image BBS converts these special characters from their encoded form to readable characters when you:

* use kbd:[RD] to read a SEQ file
* use kbd:[SB] to read a post
* Use kbd:[WF] to kbd:[.G]et, kbd:[.E]dit, and kbd:[.P]ut a file back.

The `image seq reader` utility used in BASIC also does this.

As it relates to carriage returns, though, we can see in the following table:

.Image BBS Encoded Function Keys
[%autowidth]
[%header]
|==============
| Key | Quoted | Character | Key | Quoted | Character 
| kbd:[f1] ^| kbd:[E] | kbd:[,] comma ^| kbd:[f2] ^| kbd:[I] | kbd:[?] question mark 
| kbd:[f3] ^| kbd:[F] | kbd:[:] colon ^| kbd:[f4] ^| kbd:[J] | kbd:[=] equal sign
| kbd:[f5] ^| kbd:[G] | kbd:["] quotation mark ^| kbd:[f6] ^| kbd:[K] | kbd:[Return] `chr$(13)` 
| kbd:[f7] ^| kbd:[H] | kbd:[*] asterisk ^| kbd:[f8] ^| kbd:[L] | kbd:[^] up arrow
|==============

We can take the previous example of:

 &"Hello there!"+r$

and simplify it further with:

`print"Hello there!kbd:[f6]"`

// TODO: `&"bla","bla"` and `&"bla &pound;!x"`

====

// TODO: write test program:

NOTE: Outputting a string which itself contains MCI commands or MCI string variables will not work as expected, _e.g._:

`c$="Hi":c%=3:z$="&pound;$c &pound;#3&pound;#0&pound;%c":&"&pound;$z"`

does not output `z$` (which outputs `c$`, and sets 3 leading zeroes and displays `c%`).
It will output a literal

 £$c £#3£#0£%c

Instead, do this:

`c$="Hi":c%=3:z$="£$c £\#3£# £%c":&z$`

This will output the expected

 Hi 003

====

#### `&` By Itself

This is a quick way to output the contents of `a$`.

`a$="Hello therekbd:[f6]":&`

This outputs `Hello there` and a carriage return.

#### Word-Wrap

Setting the variable `lp=1` and outputting text with `&"..."` word-wraps to 40 columns on the console, and whatever the remote user`'s screen width is.

Setting `lp=0` disables word-wrap, and words do not break at margins.

---

## `&` Parameters Explained

&,_call_

This 
&,_call_[,_optional_]

&,_call_[,_optional_[,_parameter_]]

### `&,1` Input 

`&,1` accepts input from the user.

_Parameters_:

`&,1,_editor_[,_password_]`

`p$`: text of prompt shown before `:` and input accepted

`w$`: text to use as default when using edit mode

`pl=0`: convert lowercase input to uppercase

`pl=1`: allow both lowercase and uppercase

NOTE: Not all of these parameters are currently understood.

`editor`: editor flags:

These are shown in binary, each bit controls a separate function of the input routine.
Bits may be combined together to perform multiple functions.

[%header]
[%autowidth]
|=====
| Bits | Decimal | Purpose
| `%00000001` | 1 | disallow some characters (need to decode which)

| `%00000010` | 2 | kbd:[.] or kbd:[/] on column one exits input

| `%00000100` | 4 | show prompt (`p$`)

| `%00001000` | 8 | allow kbd:[£] (the MCI command character) input

| `%00010000` | 16 | word wrap enabled

| `%00100000` | 32 | edit mode (shows first `p$`, `w$`, then another `p$` and allows kbd:[Ctrl] key editing combinations)

| `%01000000` | 64 | ignore time remaining

| `%10000000` | 128 | kbd:[Delete] on column one exits input
|=====

`password`: password flags:

[%header]
[%autowidth]
|=====
| Bits | Decimal | Purpose
| `%00000001` | 1| password mask enabled for output

[uses character in `peek(17138)`]
| `%00000010` | 2| no output
|=====

---

### `&,2` Disk File Input

`&,2,_lfn_[,_bytes_]`

Disk file input.

`lfn`: logical file number

`bytes`: number of bytes to get from file, 1-80

_Returns:_

`a$`: bytes from file

---

### `&,3` Read File from Disk

`&,3,_lfn_[,_speed_]`	read file from disk

_Parameters:_

`lfn`: logical file number

// Range 1-20 from i/GF-other:
`speed`: speed (1-20, for movie file read)

---

### `&,4` Get Byte from Modem

`&,4`	get byte from modem, `x=peek(780)` reads it

---

### `&,5` Get Version

_Returns_:

`lp`: major/minor (1.3)

`a%`: revision (1)

`a$`: date (`"12/29/91  1:18p"`)

// im 1335: "Image BBS 64 V1.3.1: 12/29/91  1:18p"

---

### `&,6` Password Input

Sets input length to 14, uses the input mask character defined in memory location `17138` to display instead of the user's input.

_Parameters:_

_Returns:_

`an$`: password

---

### `&,7` Load File

_Syntax:_ `&,7,_device_[,_segment_]`

			13: wedgemem

---

### `&,8` Disk Directory

_Parameters:_

`&,8,_lfn_,_y_`

_lfn_: logical file #

// TODO: Double-check this:
_y_: [`0`=entire directory | `1`=single line]

_Returns:_

_y_=`0`: Displays directory

_y_=`1`, `a$`: single line of disk directory information

.Reading Disk Directory
 3000 dr=1:gosub 3:open 2,dv%,0,dr$+"$":get#2,a$,a$ <1>
 3002 &,8,2,0:close 2:goto 300 <2>

<1> `dr=1:gosub 3`: get device of `s.` disk.
`open 2,dv%,0,dr$+"$"`: open the directory (the secondary address must be `0` to instruct the drive to return the disk directory as a BASIC-formatted series of lines.)
`get#2,a$,a$`: discard the load address information.

<2> `&,8,2,0`: Get entire disk directory. `close 2`: close lfn#2. `goto 300`: go to main prompt.

---

### `&,9` Bottom Variable

Print variables to 16 character status window.

`&,9[,x]`

`&,9[,0]` print `an$` to status window

`&,9,1`	print `a$` to status window

`&,9,2` print `b$` to status window

`&,9,4` looks like `d1$`

(x seems to follow the variable table definitions of Image 1.2)

---

### `&,10` Terminal Mode

kbd:[C=,Ctrl] leaves terminal mode

---

### `&,11` Clear Array

Clear array #_x_.

---

### `&,12` New User

Non-abortable file read.

---

### `&,13` inchr

NOTE: Researching this.

// arbit

---

### `&,14` Dump Array

Write array elements to an already-open file, using logical file #2.

`&,14,_array_` Output however many elements were `DIM`ensioned for the array

`&,14,_array_,_end_` Output elements 1-_end_

NOTE: See <<array-table>> for the arrays which correspond to _array_.

---

### `&,15` Convert `an$`

This group of functions perform various conversions on the string contained in `an$`.

.Example 1:
`&,15[,0]`
`an$=d1$:&,15:&an$` -> displays verbose date

. `an$=d1$`:
Put current 11-digit date (`d1$`) into `an$`, _e.g._ `60429218427`

. `&,15`:
Convert 11-digit date to a long date string, _e.g._ ``Thu Apr 29, 2021&nbsp;&nbsp;4:29 PM PST``

. `&an$`:
Output it

---

`&,15,1`::
Changes an all uppercase string to mixed case.

`an$="THE CHIEF":&,15,1:&an$` -> `The Chief`

---

`&,15,2`::
Converts encoded function key characters into readable characters

`i.t`::
`an$="hostkbd:[f3]port":&,15,2:&"&pound;v7kbd:[f6]"` -> `host:port`

``&,15,3`` and ``&,15,4``::
(These point to, and are the same as, `&,15,2`.)

`&,15,5`::
`newdate`

TIP: This function is currently being researched.

`&,15,6,_x_`::
Split `an$` into two strings, `an$` and `a$`, if `chr$(_x_)` or `asc("_x_")` is found in `an$`.

.Split on space, two ways

[start=1]
. `an$="Hello world":&,15,6,**32**`

This splits `"Hello world"` at the `**chr$(32)**` (space), resulting in `an$="Hello"` and `a$="world"`.

[start=2]
. `an$="Hello world":&,15,6,**asc(" ")**`

This splits `"Hello world"` at the **ASCII value of _space_** (32), resulting in `an$="Hello"` and `a$="world"`.

////
// does it support 3 methods?
[start=3]
. `an$="Hello world":&,15,6,**32**`

This splits `"Hello world"` at the `chr$(**32**)` (space), resulting in `an$="Hello"` and `a$="world"`.
////

[%autowidth]
.After split
|===
| `an$="Hello"` | `chr$(_x_)` | `a$="world"` 
|===

====
.im

 1262 &,15,6,140:uu$=an$:an$=a$
 
NOTE: `140`=kbd:[f8], Image `^`

 1472 &,15,6,133:d2%=val(an$):d1%=a:dr=.:dv%(.)=d1%:dr%(.)=d2%

NOTE: `133`=kbd:[f1], Image `,`
====

---

### `&,16`	sys 49152

Perform `sys 49152`, 

---

### `&,17`	sys 49155

---

### `&,18`	Set Screen Mode

This command turns the screen mask on or off.

_Parameters:_

`x=0`: off

`x=1`: on

---

### `&,19`	Get Version

---

### `&,20` Read from Interface Table

Reads a byte from the interface table.

_Parameters:_

`x`: index (see table)

`y`: command [`0`=put in `a%` | `1`=return in accumulator, `peek(780)`]

---

### `&,21` Write to Interface Table

Writes a byte to the interface table.

_Parameters:_

		x = index (see table)
		y = value

---

### `&,22` _x_ Tenths of a Second Delay

tenwait [x=tenths of a second]

.Example
// 2.0's i.UD-struct
[source]
----
&,22,200 <1>
----
<1> Wait 20 seconds (20 10/10^ths^ of a second)

---

### `&,23` Get Character from Modem

[source]
----
3000 &,23:c=peek(780):if c<>32 then 3000 <1>
----
<1> Get character from modem.
Save in `c`.
Loop until the caller hits kbd:[Space] [`chr$(32)`].

TIP: `&,23` doesn't stop and wait for input, unlike the `&pound;g1` MCI command.
If no character is received from the connected user, `peek(780)=0`.

// asynchronous
// 1. A process in a multitasking system whose execution can proceed independently, "in the background". Other processes may be started before the asynchronous process has finished.

---

### `&,24` xchrout1

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

---

### `&,25` Sound

Produce 4 separate sounds, optionally repeating the sound a specified number of times.

_Parameters:_

`&,25,_sound_[,_repeat_]`

_sound_=

	&,25,0  beep
	&,25,1	ding
	&,25,2	higher pitched ding
	&,25,3	gong sound from CCGMS (a terminal program)

`repeat=`
Number of times to repeat: [`0`: Stop repeat | `1-254`: Repeat count | `255`: infinite]

### `&,26` callmod

---

### `&,27` Save Variable Pointers

When modules use arrays not already defined in `im`, #FIXME#

---

### `&,28` Restore Variable Pointers

====
Image 1.2 had just one level of variable pointer save and restore.
Image 1.3 and above adds multiple levels of save and restore with this additional parameter.
====

// array pointers: $13D0-$13DF, is that 16 1-byte pointers (levels 0-15) or 8 2-byte pointers (levels 0-7)?

---

:function_count: 8
include::includes/prg-ml-function-warning.adoc[]

### `&,29` usevar

---

### `&,30` putvar

---

### `&,31` zero

---

### `&,32` minusone

---

### `&,33` getarr

---

### `&,34` putarr

---

### `&,35` getln

---

### `&,36` putln

---

###	`&,37` trapon

---

###	`&,38` trapoff

---

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

### `&,39` prtln

Prints the array element `tt$()` contained in the `.x` register.

---

###	`&,40` forcegc

Perform a garbage collection (freeing RAM by erasing unused strings).

---

###	`&,41` setbaud

---

### `&,42` ECS Commands

This group of commands are used for interfacing the Extended Command Set (ECS) with BASIC.
There are sub-commands to:

* load and save the command set
* search for and update individual commands
* `goto` or `gosub` line numbers in `im`, or modules

`&,42` Check for ECS command

This checks whether the command passed in `an$` is a valid ECS command.

_Example:_
.im
 270 f4=.:a%=zz:b%=2^ac%:&,42:if a% then ef$=b$:ep$=a$:ec=a%:ec%=b%:goto 264

_Parameters:_

`an$` command the user typed

`a%`: Local Mode flag (`zz`)

`ac%`: access level

_Returns:_

`a$`: password

`b$`:

`a%`: credits to use command

`b%`: 

---

`&,42,1` Goto line in ECS command

_Parameter:_

`a%`: line number to `goto`

_Example:_

.im
 268 a%=asc(ef$+nl$)+256*asc(mid$(ef$,2,1)+nl$):&,42,1

From an ECS flags string `ef$`, `a%` holds the line # to `goto`, using `&,42,1`.

---

`&,42,2` Get ECS definitions from RAM

_Example:_

.i/IM.ecs
 4004 &,42,2:n=a%:goto 4034

_Returns:_

`a%`: number of ECS definitions in memory

---

`&,42,3` Put ECS definition into RAM

Add/replace the ECS definition in the `tt$(_x_)` array element to the list currently in memory.

_Parameter:_

`tt$(_n_)`: command definition

`&,42,3,_number_`: the number of commands in the ECS command set

_Examples:_

.i/IM.ecs
 4010 tt$(n+1)=chr$(0):&,42,3,n+1:return

`n` is the current count of ECS commands.
Assign an empty command (`chr$(0)` is a null byte) to the next command (`tt$(n+1)`).
`&,42,3,n+1`: Add the empty command to the ECS command set.

---

`&,42,4` Load ECS definitions from disk

_Parameters:_

`a$`: filename

`dv%`: device #

_Example:_

.im
 3106 a$=dr$+"e.ecs.main":&,42,4

Load the ECS definitions in `e.ecs.main` from disk.

---

`&,42,5` Save ECS definitions to disk

_Parameters:_

`a$`: filename

`dv%`: device #

_Example:_

.i/IM.ecs
 a$=dr$+a$:&,42,5:return

---

:function_count: 9
include::includes/prg-ml-function-warning.adoc[]

 &,43	chatchk
 &,44	trace
 &,45	prtvar	[MCI on?]
 &,46	prtvar0 [MCI off?]
 &,47	carchk
 &,48	getkbd
 &,49	getmod
 &,50	outscn
 &,51	outmod outputs character in .a [peek(780)]

////
&,47 returns:
0 if carrier present, or local mode
1 if carrier dropped
2 if time out
////

---

### `&,52` Lightbar Interface

This is how to read the status of lightbar checkmarks, change checkmarks`' status, and move the "`lit`" portion to a specific location.

_Parameters:_

`&,52,_position_,_option_`

====
TIP: `&,52,$_hexadecimal_,_option_` is allowed.

_Example_: Turn off *Trc* left: `&,52,$18,0` (`&,52,24,0` decimal).
====

`option`=0: clear checkmark at _position_

`option`=1: set checkmark at _position_

`option`=2: toggle checkmark at _position_

`option`=3: read status of _position_, return in `a%` (`0`=off, `1`=on)

`option`=4: move lightbar to _position_

---

### `&,53` Logoff

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

* Resets various flags:

** chat page
** sound repeat counter

* clears status area

_Example:_

.im:

 3074 &,53

---

### `&,54` Text editor interface

	&,54,0	don't preserve text in tt$() array
	&,54,1	re-enter main
	&,54,2	re-enter, not command

---

:function_count: 2
include::includes/prg-ml-function-warning.adoc[]

### `&,55` output

---

### `&,56` chatmode

---

### `&,57` relread

Reads a record from a RELative file.

---

###	`&,58` setalarm

_Parameters:_

`&,58,_hour_,_minute_`

`hour`: hour

`minute`: minute

---

###	`&,59` farerr

Cause BASIC error to happen.

_Parameter:_

`&,59,1,_error_`

_Example:_

 &,59,1,14

Cause error `14`, `?illegal quantity&nbsp;&nbsp;error`.

.Error Numbers
[%header]
[%autowidth]
|===
| Number | Error | Number | Error
| 1 | TOO MANY FILES        |16 | OUT OF MEMORY
| 2 | FILE OPEN             |17 | UNDEF'D STATEMENT
| 3 | FILE NOT OPEN         |18 | BAD SUBSCRIPT
| 4 | FILE NOT FOUND        |19 | REDIM'D ARRAY
| 5 | DEVICE NOT PRESENT    |20 | DIVISION BY ZERO
| 6 | NOT INPUT FILE        |21 | ILLEGAL DIRECT
| 7 | NOT OUTPUT FILE       |22 | TYPE MISMATCH
| 8 | MISSING FILE NAME     |23 | STRING TOO LONG
| 9 | ILLEGAL DEVICE NUMBER |24 | FILE DATA
|10 | NEXT WITHOUT FOR      |25 | FORMULA TOO COMPLEX
|11 | SYNTAX                |26 | CAN'T CONTINUE
|12 | RETURN WITHOUT GOSUB  |27 | UNDEF'D FUNCTION
|13 | OUT OF DATA           |28 | VERIFY
|14 | ILLEGAL QUANTITY      |29 | LOAD
|15 | OVERFLOW              |30 | BREAK
|===

---

### `&,60` Structures

See the xref:prg-structures.adoc#structures[Static Arrays (Structures)] chapter in the _Programming Reference Guide_ for more information.

////
		[Ray: &,60 handles X=0,1,2,3,14,15, any other x calls &,68]

	struct%(0,0) holds # of records in a struct

	PutString: put string into structure
	Usage	&,60,0,bytes,struct%(field,record),string$
	Example:&,60,0,11,lm%(2,x),a$
		&,60,0,16,lm%(8,x),b$

	GetString: get string from structure
	Usage:	&,60,1,bytes,struct%(field,record),string$
	Example:&,60,1,50,jm%(5,fd%(i)),a$ - sub.menus

	LoadStruct: load structure from disk
	Usage:	&,60,2,0,array(a,b),"filename$",device
		third parameter always seems to be 0
		maybe array(a,b) is # of records, or struct to load
	Example:&,60,2,.,lm%(.,.),dr$+"e.loginmods",dv%:gosub5

	SaveStruct: save structure
	Usage:	&,60,3,0,struct%(.,.),bytes,filename$,device
		does 0 param always have to be 0?
		maybe struct%(.,.) stands for the array name
	Example:&,60,3,.,lm%(.,.),1271,a$,dv%
		&,60,3,.,fb%(.,.),960,a$,dv%

	PutDate: put date string into structure (BCD)
	Usage:	&,60,4,0,struct%(f,r),string$
		does "0" param always have to be 0?
		struct%(f,r)	field,record to put date into
		string$		the 11-digit date string

	GetDate: get date string from structure (BCD)

	Usage:	&,60,5,struct%(f,r),string$

		struct%(f,r)	field,record to get date from
		string$		the date string

	DoScan	Scan records (yikes)
	Usage	&,60,6,num,command,a(a,b),b(a,b),l,bits,test
		returns count in a%, and b(a,b) (a struct)
	num	# of records to scan
	command
			0	2 byte AND, <>0
			1	2 byte AND, ==0
			2	2 byte CMP, <
			3	2 byte CMP, >=
			4	date   CMP, <
			5	date   CMP, >=
	a(a,b)		starting flags element
	b(a,b)		starting object element
	l	struct width
	bits		the bits to set if true
	test		the object to test for (string variable, etc.)

	i.UD:	3950 &,60,6,rn,$4f,ud%(0,1),ud%(3,1),60,4,ld$:b%=a%
		($4f is %1001111 in binary, for what it's worth)
		scans dir for new files based on last call date?
	i.GF:	3166 &,60,6,s%(0,0),0,s%(0,1),s%(1,1),80,1,2^ac%

	sort:
	i/lo/tt maint: &,60,7,0,a$(p+1,i),n-p

	scannums	Returns an integer array result%(a)

	Usage:		&,60,8,num,size,access,search%(f,r),result%(s),start
	Returns:	a%, count of records [stored in array result%(s)] which match <access>

	num		number of records in struct
	size		size of the record in struct
	access		access level to add results to result%(a)
	search%(f,r)	struct to search (field,record)
	result%(s)	integer array to put the result in, starting at element s?
	start		element to start scanning from?

' scan struct:
' &,60,8,recs,size,access,search%(f,r),result%(e),start
' recs:		50
'	# of records in struct
' size:		60
'	size of the record in the struct
' access:	2^ac%+zz%*32768
'	access level to filter results by
' search%(field,record):	jm%(1,.)
'	search%()	the integer array to search
	field		the field within the record to search
	record		the record to search
' element:	?

	search%(f,r)	struct to search (<field>,<record>)
	result%(e)	integer array to put results in, perhaps "e" is a dummy value
	start	element to start scanning from?

' scan struct:
' &,60,8,recs,size,access,search%(field,record),result%(element),start
' recs:		50
'	# of records in struct
' size:		60
'	size of the record in the struct (seems too large: was only DIMensioned for 30)
' access:	2^ac%+zz%*32768
'	access level to filter results by
' search%(field,record):	jm%(1,.)
'	search%()	the integer array to search
	field		the field within the record to search
	record		the record to search
' element:	?

.Examples
`sub.menus`:
	dim fd%(50),jm%(29,49)
' ScanStruct returns a% (# of matches)
' this code returns fd%(): single dimension array of matching records
' (I think "1" in fd%(1) is a dummy value, although it may be significant)
	&,60,8,50,60,2^ac%+zz*32768,jm%(1,.),fd%(1),.:if a%=. then return
' &,60,1: get 50-byte string from struct jm%( , ), field [aka "offset"] 6 (zero-based)
' of record fd%(i). assign string to a$:
	&"{f6}":for i=1 to a%:&,60,1,50,jm%(5,fd%(i)),a$:lp=1:&:i=i+a%*rc:next:return

`sub.feedback`:
	a%=0:if fb%(0,0)>0 then:&,60,8,fb%(0,0),60,1,fb%(11,1),ff%(1),1
`sub.menus`:
	60014 &,60,8,50,60,2^ac%+zz*32768,jm%(1,.),fd%(1),.:if a%=. then return
`i.GF`:
 3168 rn=a%:if rn then:&,60,8,s%(0,0),80,1,s%(0,1),e%(1),1
i.lo:
	3304: &,52,4,3:&,60,8,fb%(.,.),60,2^(a%+3),fb%(11,1),ff%(1),1

	scansum		Unknown what this is for
	Usage:	&,60,9,num,siz,a(a,b)
	Returns: a% (presumably number of items scanned which exist)

	cpystruc	Copy field in struct to another field?
	Usage:	&,60,10,bytes,a1(a,b),a2(a,b)

.i/IM.logon:
Inserting a record at `fb%(0,a)`:

 4326 if x<>fb%(.,.) then for a=x to fb%(.,.)-1:&,60,10,60,fb%(.,a+1),fb%(.,a):next

.i/GF-add:
again, inserting a record

 3324 if x<>cm%(0,0) then for a=x to cm%(0,0)-1:&,60,10,100,cm%(0,a+1),cm%(0,a):next

	scanstr		Unknown what this is for
	Usage:	&,60,11,num,siz,op,str,a1(a,b),a2(b),start
	No examples yet.

gamescan
&,60,12,count,size,a$,a%(a,b),b$

No examples yet.

; textread:
; &,60,13,number,reclen,scan(),bits,text(),strlen

No examples yet.
////

---

###	`&,61` poscrsr

Move the terminal cursor to a specified column and row on the screen.

_Parameters:_

`&,61,column,row`

====
NOTE: `0,0` is the top left corner of the screen.
====

.im
 4006 &,38:&,61,.,8:print"&,37:goto 1812:":end

Position the cursor at column 0, row 9 (`&,61,0,8`) to print recovery information for when the BBS crashes.

// what is the difference between &,61 and &,70?

---

### `&,62` Set Time

Set BBS clock.

// CIA timer?

_Parameters:_

`&,62,_hour_,_minute_`

`hour`: hour

`minute`: minute

_Example:_

.im:
 3184 &,62,h,m

---

:function_count: 3

include::includes/prg-ml-function-warning.adoc[]

### `&,63` inline1

---

### `&,64` convstr

---

### `&,65` convert

---

### `&,66` Calculated GOTO

`goto` line number held in `a%`.
If you have 14 `goto` targets on a line, this can save a fair amount of RAM (and BASIC interpretation time).

`a%`: line number to `goto`

Instead of writing:

`on a% goto 3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300` (79 bytes)

The same thing can be written like so:

`a%=3:a%=a%*100+3000:&,66` (24 bytes)

to go to line 3200.

---

### `&,66,1` mlgosub

---

### `&,67` copyrite

---

### `&,68` struct


---

// [Ray: Certain sub-functions of &,60 are re-directed here]

### `&,69` Display String on Console

_Parameters:_

`&,69,_column_,_row_,_text_,_color_`

`column`: `0-39`

`row`: `0-24`

`text`: `a$`, `"Hi there!"`, or `"Hi there, "+a$+"!"`

`color`: is `1-15` for un-reversed colors.
For reversed colors, add `$80` (or 

// not sure MCI commands can be included

NOTE: Upper left of the screen starts at column 0, row 0.

NOTE: This function will not draw PETSCII graphics characters properly.

_Example_

 &,69,4,21,left$(" "+cm$+"{21 spaces}",22),$8c

[start=1]
. `&,69,4,21` position string at column 5, row 22

[start=2]
. `left$(" "+cm$+"{21 spaces}",22)` formats the string so it`'s left-justified in the 22-character `Area` window

[start=3]
. `$8c` draws the string in reverse (`$8`) in color `$c` (decimal 13, light green)

TIP: The module `sub.display` is a good example of using `&,69`.

_Parameters:_

TIP: Upper left corner of the screen is `0,0`.

`column`: `0-39`

`row`: `0-24`

`color`: ``1-15``, same as the MCI colors (black, `0`, is excluded).
`$8x` is reverse color _x_ (`$81` is reverse white, `$8f` is reverse light gray).

Question::
Will this plot stuff to the screen mask area when in full screen mode? I'm pretty sure it does.

// [[70-position-cursor]] does not work

### `&,70` Position terminal cursor [[position-cursor]]

_Parameters_:

`&,70,_column_,_row_`

TIP: Upper left corner of the screen is `0,0`.

`column`: 0-39

`row`: 0-24

.i.IM
 &,70,.,n/2+8.5:&"{white}"

.Fancy Title
****
.Question for the Ages:
What is the difference between `&,61 (poscrsr)` and `&,70 (cursposn)`?
****

////
"menu.s" is source for "++ 2" (cursor menu)
	(from source:)
; 0 - # entries
; 1 - item type character
;2,3- item value
;4,5- credits to charge
;6,7- access
;8-39 - text
	(must refer to bytes in struct)

	(from i.IM)
&,16,.,34,m%(.,1),"A","","*Macros Editor"

&,16,2,34,m%(.,1),n,17,2,n/2+.5,2,6,.

lm=a%+1 [returns a% value, probably which item was selected]
////
