:experimental: // enable kbd:[] macro

### `&` Routines

`&` is the command character which is BASIC's interface to 70 machine language routines of Image BBS.

====
NOTE: This section is undergoing discovery of what some routines are for and how they are used.
====

#### `&`: Image BBS Output

In BASIC, the `print` keyword (or its abbreviation, `?`) displays text on the screen, as in:

[source,basic]
print"Hello there!"

You can substitute `&` in Image BBS to do the same thing:

[source,basic]
&"Hello there!"

But unlike BASIC, after outputting this text, the cursor remains on the same line--there is no automatic carriage return printed.

It's as if a semicolon (`;`) was used after the `print` statement above--this keeps the text all on one line:

[source,basic]
print"Hello ";"there!";

vs. printing on two lines:

[source,basic]
print"Hello"
print"there!"

To work around this, you can output a _carriage return_, which moves the cursor to the beginning of the next line.

====
.Boring Background: CR/LF, CR, LF?
On other terminals or operating systems, a carriage return moves the cursor to the beginning of the current line.

Sometimes an additional _linefeed_ character is needed, which keeps the cursor in the current column, but moves the cursor down a row.

 Hello
       there!

This stairstep-looking result is what printing looks like with only a linefeed, when the terminal needed both a carriage return and a linefeed.
Probably not the desired result.

However, ``print``ing in Commodore BASIC--and our BBS in this example--doesn't need a linefeed.
A carriage return is the equivalent of a carriage return plus linefeed.
====

[source,basic]
&"Hello there!"+chr$(13)

`chr$()` (read it as "`character string`") is a function that outputs a character supplied in parentheses.
A carriage return is `chr$(13)`.
So this snippet of code will output `Hello there!`, then move the cursor to the beginning of the next line.

There is also a string variable defined in `im`: `r$=chr$(13)` (short for "`return`").
This is a handy shortcut.
You can now code:

[source,basic]
&"Hello there!"+r$

// TODO: data file tutorial

TIP: Using the `r$` variable is actually an easy way to write data containing carriage returns to a SEQ file, as you'll see later.

But there's something even handier available.

#### Encoded Function Keys

Some special characters are difficult (or impossible) to type in BASIC.
Or, they might cause problems while reading disk files.
Therefore, they have been encoded using the reverse video letters seen while typing function keys when in Commodore's "`quote mode.`"

This eliminates a few difficulties:

* Entering special characters is made easier--instead of `chr$()` codes, you can just tap a function key in quote mode

* Some more simply written code (and BASIC itself) can truncate data when a `,` is encountered in a SEQ file--this character encoding eliminates that problem

Image BBS converts these special characters from their encoded form to readable characters when you:

* use kbd:[RD] to read a SEQ file
* use kbd:[SB] to read a post
* Use kbd:[WF] to kbd:[.G]et, kbd:[.E]dit, and kbd:[.P]ut a file back.

The `image seq reader` utility used in BASIC also does this.

TIP: A new `&` command, `&,15,2`, does the same thing when passed `an$`, the string to translate.

As it relates to carriage returns, though, we can see in the following table:

.Image BBS Encoded Function Keys
[%autowidth]
[%header]
|==============
| Key | Quoted | Character | Key | Quoted | Character
| kbd:[f1] ^| kbd:[E] | kbd:[,] comma ^| kbd:[f2] ^| kbd:[I] | kbd:[?] question mark
| kbd:[f3] ^| kbd:[F] | kbd:[:] colon ^| kbd:[f4] ^| kbd:[J] | kbd:[=] equal sign
| kbd:[f5] ^| kbd:[G] | kbd:["] quotation mark ^| kbd:[f6] ^| kbd:[K] | kbd:[Return] `chr$(13)`
| kbd:[f7] ^| kbd:[H] | kbd:[*] asterisk ^| kbd:[f8] ^| kbd:[L] | kbd:[^] up arrow
|==============

_Key_ is what you type on the Commodore 64 keyboard.

_Quoted_ is what it looks like in "`quote mode.`"

_Character_ is what the encoded character represents.

#### `&` By Itself

This is a quick way to output the contents of `a$`.

`a$="Hello therekbd:[f6]":&`

This outputs `Hello there` and a carriage return.

We can take the previous example of:

[source,basic]
&"Hello there!"+r$

and simplify it further with:

`&"Hello there!kbd:[f6]"`

// TODO: `&"bla","bla"` # test this

====
TIP: Because of a quirk in the BASIC interpreter, you must follow a `then` clause with a colon before using the ampersand.

In other words, the following results in a `?syntax&nbsp;&nbsp;error`:

[source,basic]
if b then &"hello"

This must be used instead:

[source,basic]
if b then:&"hello"
====

### BASIC Editing Modes

#### Quote Mode
In the BASIC editor, once the quote mark (kbd:[Shift+2], kbd:["]) is typed, color or cursor controls stop changing the cursor color or moving the cursor.
Instead, they start displaying reversed characters which stand for the color control, cursor control or symbol you are typing.
Once the text inside the quotes is ``print``ed, they perform their functions as if typed manually.
The kbd:[Inst/Del] key is the only cursor control not affected by "`quote mode.`"

Typing a second kbd:["] exits quote mode, and allows you to use the cursor keys to edit the program line again.

====
TIP: See <<position-cursor>> for how to easily move the terminal cursor within Image BBS, instead of using lots of cursor controls in quote mode.
====

#### Insert Mode
Insert mode is similar to quote mode, only for the number of spaces you insert with the kbd:[Shift+Inst/Del] key, the BASIC editor is in quote mode.
Once the space inserted has been typed in, insert mode is exited.

====
TIP: kbd:[Return] gets out of quote and insert mode, and adds the current line into the BASIC program.

kbd:[Shift+Return] gets out of quote and insert mode, but does _not_ add the current line into the BASIC program.
====

---

### Outputting Strings

#### String Literals

#### String Variables

#### Concatenation

#### Word-Wrap

// source: foldoc.org

A new feature of the text output routine is _word-wrap_.
This is where a word which would extend past the right hand margin is moved to the following line instead.

The position to wrap words is usually 40 columns on the console, whatever the remote user`'s screen width is, and 80 columns on the printer, if one is attached.

Setting the variable `lp=1` and outputting text with `&"..."` will enable word-wrap.

Setting `lp=0` disables word-wrap, so words continue past the right margin.

#### Set Margins

The left and right margins can now be indented by up to 15 characters using two new MCI commands:

// source: s.menu 3

* `£m<__x__` (set left margin).
This command causes every carriage return issued by Image BBS to be followed by _x_ spaces, which indents text _x_ spaces.
The values for _x_ are `0` (to disable word-wrap), or `1-9`, and `j-o` (10-15).

* `£m>__x__` (set right margin).
This command causes the system to word wrap as if the user's screen width was _x_ characters less than it really is.
It indents the text from the right side.

The use of `£m<__x__` and `£m>__x__` together allows you to make "`block indents`" of text that appear correct regardless of the user's screen width.

#### MCI Commands

#TODO#

====

// TODO: write test program:

NOTE: Outputting a string which itself contains MCI commands or MCI string variables will not work as expected, _e.g._:

[source,basic]
c$="Hi":c%=3:z$="£$c £#3£#0£%c":&"£$z"

does not output `z$` (`£$c` outputs `c$`, `£#3` sets 3 leading characters, `£#0` sets the fill character to `0`, and `£%c` displays the value of `c%`).
It outputs a literal

 £$c £#3£#0£%c

Instead, do this:

[source,basic]
c$="Hi":c%=3:z$="£$c £\#3£# £%c":&z$

This outputs the expected

 Hi 003

====

### Outputting Numbers

#### Integers

#### Floating Point

_Floating point_ values are not integers--the value could be fractional, and the decimal point could be in any position, hence the term "`floating point.`"

`&str$(h)`::
Since `&h` isn't supported to output the value of `h`, it must be converted to a string with the `str$()` function.

TIP: `&str$(h)` is still useful if the number of digits output is greater than 5, the limit of the MCI numeric output routine.

`&str$(h)` worked under Image 1.2; it works here too, but there is a new MCI command in Image 3.0 to output single-letter floating point variables:

`&"£!h"`::
Output the value of `h`.

To output a two-character variable name (_e.g._, `xx`, `c1`), you have some choices:

* assign the two-character variable name to a single letter variable name, _e.g._:

[source,basic]
x=xx:&"Blocks free: £!x"

* output the two-character variable using the `str$()` function:

`&"Number of days:"+str$(xx)`::
Output the value of `xx`.

## ``&`` Parameters Explained

`&` commands from this point on have additional parameter(s) called by at least one number, followed by optional parameter(s).
These variables are denoted in _italics_.

`&,_call_`::
This means that `&,` is required, but the value of _call_ varies.
Substitute the appropriate number in its place.

.Example

`&,40`: perform garbage collection

`&,_call[,optional]_`::
This means that, again, `&,_call_` is required.
The value of _call_ varies.
However, the parameter _[,optional]_ is not required.
If it is supplied, there needs to be a `,` and the appropriate parameter substituted in its place.

.Example

`&,9,1`: display `a$` in the 16-character programmable window

// &,_call_[,_optional_[,_parameter_]] -- don't think this ever happens

There are various sections which most commands use.
They outline BASIC setup (variables or ``poke``s) which need to be done before the `&` call can be used.

_BASIC Setup:_ ::
Any ``poke``s or BASIC variables which are used by the ``&`` command are listed here.

_Parameters:_ ::
Any extra information given after `&,_x_`, like strings or numbers, are listed here.

_Returns:_ ::
Strings, numbers or arrays returned when the `&` command is finished are listed here.

_Examples:_ ::
Examples of setup, the `&` call being used, and some typical results are listed here.

---

### `&,1` Input Line

`&,1` accepts input from the user at a prompt.
It handles features including word wrap, MCI access, line length, and the ability to type graphics characters.

_BASIC Setup:_

`poke 53252,_line_length_` limits the length of the input to _line_length_ characters, 1-79.

`p$`: text of the prompt shown before `:&nbsp;` and input is accepted.

`w$`: the default response to a prompt.
When using edit mode, if only kbd:[Return] is typed at a prompt, `an$` is set to a null string (`an$=""`).
The module can check for this and not update the original string.
An example is given below.

// from &,1 documentation

`pl=0`: allow both lowercase and uppercase.

`pl=1`: convert lowercase input to uppercase.

_Parameters:_

`&,1,_editor_[,_password_]`

====
NOTE: Not all of these parameters are currently understood.
====

`editor`: editor flags:

Each bit controls a separate function of the input routine.
Bits may be combined together to perform multiple functions.

[%header]
[%autowidth]
// [%frame=no]
|=====
| Binary | Decimal | Purpose (if set)
| `%00000001` | 1 | disable typing graphics characters

| `%00000010` | 2 | kbd:[.] or kbd:[/] on column one exits input

| `%00000100` | 4 | disable prompt (`p$`)

| `%00001000` | 8 | disable typing kbd:[£] (the MCI command character)

| `%00010000` | 16 | enable word-wrap

| `%00100000` | 32 | enable edit mode

| `%01000000` | 64 | ignore time remaining

| `%10000000` | 128 | disable typing kbd:[Delete] on column one to exit input
|=====

_Returns:_

[%header]
[%autowidth]
|=====
| Variable | Purpose
| `an$` | 1 | disable typing graphics characters
|=====

[%header]
[%autowidth]
|=====
| `peek()` | Purpose
| `$d006/53254` | 0: normal

1: kbd:[Delete], kbd:[.] or kbd:[/] typed on column 1


|=====

//* location (chat) holds:
//* 0 = normal *
//* 1 = delete on column one *
//* or dot on column one *
//* 2 = chat check hit *
//* 3 = carrier/time loss *

_Explanations:_

#TODO#: demonstrations of each mode in `i.test calls`

Edit mode::
The prompt (`p$`) is displayed, and the default response (`w$`) is displayed.
Then, the prompt (`p$`) is displayed again, and one of three choices can be made:

* kbd:[Return] accepts the default (`w$`)
* a new string can be typed
* the current string can be edited using kbd:[Ctrl] key shortcuts

`password`: password flags:

// NOTE: These haven't been tested, just going by what Ray said

[%header]
[%autowidth]
|=====
| Binary | Decimal | Purpose
| `%00000001` | 1| password mask enabled for output

[uses mask character in `peek(17138)`]

| `%00000010` | 2| no output
|=====

_Returns:_

`an$`: text typed at the prompt.

_Examples:_

#TODO#: write examples for each option.

.Example 1:
[source,basic]
poke 53252,10:p$="Name":&,1

`poke 53252,10`: Set the input length to 10 characters.

`p$="Name"`: Set the prompt to `Name:`.

`&,1`: Allow user input, and return string in `an$`.

.Example 2:
[source,basic]
poke 53252,20:w$=na$:p$="Handle":&,1,32:if an$<>"" then na$=an$

`poke 53252,20`: Set the input length to 20 characters.

`w$=na$`: Assign the user's handle (`na$`) to `w$` (the prompt's default).

`p$="Handle"`: Set the prompt to `Handle:`.

`&,1,32`: Setting bit 5 (a value of 32) enables edit mode.
This displays the prompt, the original text (`w$`), and re-displays the prompt.
Editing control keys can be used to change the input.
Editing mode looks like this:

 Handle: PINACOLADA
 Handle: _

The string typed in response to a prompt is returned in `an$`.

`if an$<>"" then na$=an$`: Just typing kbd:[Return] (to accept the default, `w$`) sets `an$` to a null string.
If something else was typed (`an$<>""`), assign `na$` to what was typed (`an$`).

.Example 3:
[source,basic]
poke 53252,30:p$="New Prompt":&,1,9:if an$<>"" then po$=an$

`poke 53252,30`: Set the input length to 30 characters.

`p$="New Prompt"`: Set the prompt to `New Prompt:`.

`&,1,9`: Setting bits 3 and 0 (a value of 8 + 1) allow MCI and graphics characters to be entered.

---

### `&,2` Disk File Input

Input data from an open disk file.
This routine inputs a maximum of 80 characters into `a$`.

_Parameters:_

`&,2,_lfn[,bytes]_`

`lfn`: logical file number.

====
.Logical File Numbers
// source: C64 Programmer's Reference Guide, modified
A logical file number (LFN) relates the `open`, `close`, `cmd`, `get#`, `input#` and `print#` statements to each other.

LFNs help distinguish multiple files from each other.
They associate the commands being used with the filename opened which uses the same LFN.

The LFN is the first number in an `open` statement, _e.g._ `open **2**,10,2`.

////
This and can be a useful debugging tool.
If you have an input file open on LFN \#1, and an output file open on LFN \#2, #FIXME#
////

The LFN value ranges from 1 to 255.
LFN 15 is usually reserved for the DOS command channel.

The only restriction is that you can't re-`open` a LFN that is already `open`, or you get the error `?file open&nbsp;&nbsp;error`.
====

`bytes`: number of bytes to get from file (1-80).
Carriage returns are ignored.

_Returns:_

`a$`: bytes from file

_Example:_

.s.test file
----

data <1>
----+----+----+----+----+----+ <2>
----

<1> a regular string

<2> a 30-character string, used to demonstrate `&,2,2,25`

.i.read test file
```
3000 dr=1:a$="s.test file,s,r":gosub 4 <1>
3002 if e% then:&:goto 3100 <2>
3004 &,2,2:& <3>
3006 &,2,2,25:& <4>
3100 close 2:goto 300 <5>
```

<1> `dr=1`: set the Image drive to `1` (the System drive).
`a$="s.test file,s,r"`: set the System disk filename prefix to `s.`, the main filename to `test file`, specifies `s` for a SEQuential file, and `r` for reading the file.
`gosub 4`: open `a$` for the device and drive assigned to the System drive.

<2> If there is a DOS error (_e.g._ `file not found`), this line intercepts it.
`e%`: the DOS error number.
`if e%` implies `if e%<>0` (if `e%` does not equal zero; _i.e_., a non-zero result means an error occurred).
`a$`: the DOS error string.
`&`: display the DOS error string in `a$`.
`goto 3100`: close the disk channel instead of getting data from a non-existant file.

<3> `&,2,**2**`: using logical file #**2**, get a line of data from the disk.
The data is returned in `a$`.
`&`: output `a$`.

<4> `&,2,2,**25**`: using logical file #2, get a line of data from the disk--but stop at *25* characters, instead of getting the entire line.
The data is returned in `a$`.
`&`: output `a$`.

<5> `close 2`: close disk file.
`goto 300`: go to main prompt.

.BASIC Pitfall
// [code]
====
Using `input#2,a$` when the disk file contains a string `hello,there` returns only `hello` in `a$`.
When used with `input#`, `,` is a delimiter which truncates (cuts off) the data after the `,`.

You can prefix the string with `"` on disk to get around that.
But most likely, you want to read `hello` and `there` into two separate variables.
`input#2,a$,b$` does that, resulting in `a$="hello"` and `b$="there"`.
====

---

### `&,3` Read File from Disk

Read a file from disk.
An optional _speed_ parameter can be specified for reading movie files, which adds an appropriate slowdown based on the value.

_Parameters:_

`&,3,_lfn_[,_speed_]`

`lfn`: logical file number

// Range 1-20 from i/GF-other:
`,speed`: speed (`1`-`20` for movie file read. `1`=faster, `20`=slower)

---

### `&,4` Get Byte from Modem

This returns the character received from the modem in `peek(780)`.
This routine does no ASCII translation, and no high bit stripping; it gets the character directly from the RS232 routines.

_Returns:_

`x=peek(780)` reads the character from the RS232 routines.
If no character is received from the modem, `peek(780)=0`.

---

### `&,5` Get Version

Get the version information embedded in the BBS ML.

_Returns_:

`lp`: major/minor (1.3)

`a%`: revision (1)

`a$`: date (`"12/29/91  1:18p"`)

// im 1335: "Image BBS 64 V1.3.1: 12/29/91  1:18p"

---

### `&,6` Password Input

Sets the input length to 14, and displays a definable mask character rather than the actual characters typed.
The text typed is returned in plain (non-masked) text.

_Parameters:_

`poke 17138,_mask_`: display _mask_ character instead of the user's input

You could do `poke 17138,asc("X")` to set the mask character to `X`.

_Returns:_

`an$`: password in plain text

_Example:_

.im
[source,basic]
263 &"Password: ":&,6:if an$<>ep$ then:&"Incorrect Password."

`&"Password: "`: Display the prompt ``Password: ``.

`&,6`: Allow password entry, displaying the mask character instead of the text actually typed.

`if an$<>ep$ then:&"Incorrect Password."`: if `an$` (the entered text) is not equal to (`<>`) `ep$` (a password set on an Extended Command Set command), display the message.

---

### `&,7` Load File [[load-file]]

Loads a module into memory.

_Parameters:_

`a$`: the drive number and filename (_e.g._, `"0:i.module"`)

_Syntax:_

`&,7,_device_[,_segment_]`

====
.Segments
Segments are pre-defined addresses that a module will load to, regardless of the file's first two bytes which define its load address.

Not all segments are currently defined.

[%autowidth]
[%header]
|====================
^| Segment <| Purpose
^| 2  | Protocols or blocks of ML
^| 7  | Print mode table
^| 8  | Lightbar text
^| 9  | Alarm table
^| 10 | ASCII-to-Commodore translation table
^| 11 | Commodore-to-ASCII translation table
^| 12 | Print mode table

|====================

////
    .word 0 //0
	.word 0 //1
	.word protostart //2
	.word 0 //3
	.word 0 //4
	.word 0 //5
	.word 0 //6
	.word pmodetbl //7
	.word bartbl //8
	.word alarmtb //9
	.word tblatc //10
	.word tblcta //11
	.word netalrm //12
    // 13: wedgemem - no practical purpose
////
====

.im:
[source,basic]
29 ml$="++ "+a$:a$=dr$+ml$:&,7,dv%,2:goto 5

This line loads an ML protocol (`++` file).

[source,basic]
ml$="++ "+a$

Assign `ml$` the ``++ `` prefix for error reporting purposes.

[source,basic]
a$=dr$+ml$

Concatenate `dr$` (the current drive prefix) and `ml$` (discussed above) into `a$`.

[source,basic]
&,7,dv%,2

Do a module load using device `dv%` into segment 2 (the protocol address, `49152` or `$c000`).

[source,basic]
goto 5

Check for a DOS error.

### `&,8` Disk Directory

Display either:

* an entire disk directory at once, from the directory header  to the `blocks free.` message
* a line of information at a time (calling it multiple times  will get the directory header, each file's block count, filename, filetype, splat and lock status, and the `blocks free.` count)

_Parameters:_

`&,8,_lfn_,_flag_`

`lfn`: logical file #

// Double-checked from sub.local
`flag`: [`0`=entire directory | `1`=single line]

_Returns:_

`flag=0`: Displays entire directory

`flag=1`: `a$`: single line of disk directory information

.Display Entire s. Disk Directory
 3000 dr=1:gosub 3:open 2,dv%,0,"$"+dr$+"*":get#2,a$,a$ <1>
 3002 &,8,2,0:close 2:goto 300 // <2>

<1> `dr=1:gosub 3`: get device of `s.` disk.
`open 2,dv%,**0**,"$"+dr$+"\*"`: open the directory as a file. The secondary address must be **`0`** to instruct the drive to return the disk directory as a BASIC-formatted series of lines, displayable by this routine. `$0:*`: Use the wildcard pattern `*` (all files). `get#2,a$,a$`: discard the load address information.

<2> `&,8,**2**,0`: Use lfn#**2** to get the entire disk directory (`0`). `close 2`: close lfn#2. `goto 300`: go to main prompt.

---

### `&,9` Bottom Variable

Output variables to 16-character status window.

_Parameters:_

``&,9[_,x_]``: _x_=variable number to display, 0-49:

[%autowidth]
[%header]
|====================
|  Variable  |  Variable  |  Variable  |  Variable  |  Variable
|  ``0 an$`` | ``10 tt$`` | ``20 nl `` | ``30 a% `` | ``40 f1$``
|  ``1 a$ `` | ``11 na$`` | ``21 ul `` | ``31 b$ `` | ``41 f2$``
|  ``2 b$ `` | ``12 rn$`` | ``22 qe `` | ``32 dv%`` | ``42 f3$``
|  ``3 tr$`` | ``13 ph$`` | ``23 rq `` | ``33 dr$`` | ``43 f4$``
|  ``4 d1$`` | ``14 ak$`` | ``24 ac%`` | ``34 c1$`` | ``44 f5$``
|  ``5 d2$`` | ``15 lp `` | ``25 ef `` | ``35 c2$`` | ``45 f6$``
|  ``6 d3$`` | ``16 pl `` | ``26 lf `` | ``36 co$`` | ``46 f7$``
|  ``7 d4$`` | ``17 rc `` | ``27 w$ `` | ``37 ch$`` | ``47 f8$``
|  ``8 d5$`` | ``18 sh `` | ``28 p$ `` | ``38 kp%`` | ``48 mp$``
|  ``9 ld$`` | ``19 mw `` | ``29 tr%`` | ``39 c3$`` | ``49 mn%``
|====================

_Examples:_

`&,9[,0]`: output `an$` to status window

`&,9,1`: print `a$` to status window

`&,9,2`: print `b$` to status window

`&,9,3`: output `tr$` to status window

`&,9,4`: output `d1$` to status window

---

### `&,10` Terminal Mode

kbd:[C=,Ctrl] leaves terminal mode

---

### `&,11` Clear Array

Clear array #_x_.

.Array Numbers
[%header]
[%autowidth]
|===
^| Number | Array
^| 0 | `tt$()`
^| 1 | `bb$()`
^| 2 | `dt$()`
^| 3 | `ed$()`
^| 4 | `nn$()`
^| 5 | `a$()`
^| 6 | `c$()`
^| 7 | `d$()`
^| 8 | `e$()`
^| 9 | `f$()`
^| 10| `ac%()`
^| 11| `so%()`
|===

////
arrays1:
		.text "tbdenACDEFAS"
arrays2:
		.text "TBTDN"
		.byte $80, $80, $80, $80, $80
		.text "CO"
////

_Example:_

`&,11`::
Clear `tt$()` array.

---

### `&,12` New User

Non-abortable file read.

---

### `&,13` arbit

A function reserved to arbitrate port use in multi-port Lt.Kernal hard drive setups.

====
NOTE: This is currently being researched.
====

---

### `&,14` Dump Array

Write array elements to an already-open file, using logical file #2.

`&,14,_array_`::
Output from 1 to however many elements were ``dim``ensioned for _array_.

`&,14,_array_,_end_`::
Output elements of _array_ from 1-_end_.

////
TODO: array table

====
NOTE: See <<array-table>> for the arrays which correspond to _array_.
====
////

---

### `&,15` Convert `an$`

This group of functions perform various conversions on the string contained in `an$`.

#### `&,15` Convert Date

`an$=d1$:&,15:&an$` -> displays verbose date

. `an$=d1$`:
Put current 11-digit date (`d1$`, _e.g._ `60429218427`) into `an$`

. `&,15`:
Convert 11-digit date to a long date string, _e.g._ ``Thu Apr 29, 2021&nbsp;&nbsp;4:29 P`` and assign that to `an$`

. `&an$`:
Output `an$`

##### Image BBS Date Format [[date-format]]

Image BBS uses an 11-digit string to represent a time and date.
The format is `w&nbsp;yr&nbsp;mo&nbsp;dt&nbsp;hr&nbsp;mi`.

====
NOTE: Extra spaces between the numbers have been added for ease of reading, but are not used in the actual string.
====

////
1  90 11 03 80 45    IMAGE BBS will translate this into the string
^  ^  ^  ^  ^  ^     "Sun, Nov  3 1990  12:45 PM"
|  |  |  |  |  |
|  |  |  |  |  +---- Minute   00-59
|  |  |  |  |
|  |  |  |  +------- Hour     00-11: AM
|  |  |  |                    80-91: PM (subtract 80 to get correct hour)
|  |  |  |
|  |  |  +---------- Date     01-31
|  |  |
|  |  +------------- Month    01-12
|  |
|  +---------------- Year     00-99     (plus hard-coded century base)
|
+------------------- Weekday   1-7      (1=Sunday...7=Saturday)
////

.Image BBS Date Format
[%autowidth]
[%header]
[cols="<,^,<,<"]
|===
| Position | Abbreviation | Purpose | Range
| 1     | `**&nbsp;w**` | weekday | `1`=Sun...`7`=Sat
| 2-3   | `**yr**` | year    | `00`...`99` (the year within the century, `20xx`, is displayed using `&,15`)
| 4-5   | `**mo**` | month   | `01`...`12`
| 6-7   | `**dt**` | date    | `01`...`31`
| 8-9   | `**hr**` | hour    | `00`...`11` (12:00 AM, midnight--11:00 AM, 1 hour until noon)

`80`...`92` (12:00 PM, noon--11:00 PM, 1 hour until midnight)
| 10-11 ^| `**mi**` | minute  | `00`...`59`
|===

The current time and date is stored in the string `d1$`, which is continually updated by the ML.
Here is a sample definition of `d1$`:

 "22105178944"

Let's break down how the string is encoded.

.Image BBS Date Decoding
[%autowidth]
[%header]
[cols="<,^,<,<"]
|===
| Position | Value | Purpose | Meaning
| 1     | `&nbsp;2` | weekday | `Mon`
| 2-3   | `21` | year    | `2021`
| 4-5   | `05` | month   | `May`
| 6-7   | `17` | date    | `17`
| 8-9   | `89` | hour    | `&nbsp;9:00 PM` (`9`=hour, plus `80`=PM)
| 10-11 | `44` | minute  | `44`
|===

As the table above shows, this string stands for `Mon May 17, 2021&nbsp;&nbsp;9:44 PM`.

====
NOTE: You can also output kbd:[Ctrl+d] or `chr$(4)` in an `&` statement to convert an 11-digit date/time string to a long date/time string.
Both these statements output the same string as above:

* `a$="22105178944":&"kbd:[Ctrl+d]"+a$`
* `a$="22105178944":&chr$(4)+a$`

// Jay Campey:
Outputting the date and time this way also outputs the user's time zone.
====

---

#### `&,15,1` Title Case

Changes an all uppercase string to mixed case.

`an$="THE CHIEF":&,15,1:&an$` -> `The Chief`

---

#### `&,15,2` Decode Function Keys

Decodes quoted function key characters into readable equivalents.

`i.t`::
`an$="hostkbd:[f3]port":&,15,2:&"£v7kbd:[f6]"` -> `host:port`

---

#### ``&,15,3`` and ``&,15,4``

These point to, and are the same as, `&,15,2`.

---

#### `&,15,5` newdate

Some sort of hour (?) conversion.

_Syntax:_

`an$="_wyymmddhhmm_":&,15,5:&"kbd:[Ctrl+d]"+an$`

====
NOTE: This function is currently being researched.
====

---

#### `&,15,6` Scan String

Scan `an$` for the first occurrence of a specified character.
You can specify the character to scan for in one of two ways:

* _x_, the PETSCII value of the character
* use the `asc("_x_")` function, which returns the ASCII (or PETSCII) value of character _x_

If the specified character is found in `an$`, split it into two strings:

* `an$` now ends before the specified character was found
* `a$` begins after the specified character was found to the end of the string

.Split on space, two ways
****
[start=1]
. `an$="Hello world":&,15,6,**32**`

This splits `"Hello world"` at `**chr$(32)**` (kbd:[Space]), resulting in `a$="Hello"` and `an$="world"`.

[start=2]
. `an$="Hello world":&,15,6,**asc(" ")**`

This splits `"Hello world"` at the **ASCII value of kbd:[Space]** (32), resulting in `a$="Hello"` and `an$="world"`.

After the split, the two strings look like this:

[%autowidth]
|===
| `a$="Hello"` | `chr$(32)` | `an$="world"`
|===

////
// does it support 3 methods?
[start=3]
. `an$="Hello world":&,15,6," "`

This splits `"Hello world"` at the `" "` (space), resulting in `a$="Hello"` and `an$="world"`.
////
****

====
TIP: If the specified character is not found in `an$`, `a$=""`, a null string.
====

====
.im

`312 &,15,6,**140**:uu$=an$:an$=a$`

NOTE: `140`=kbd:[f8], Image `^`

 352 &,15,6,133:d2%=val(an$):d1%=a:dr=.:dv%(.)=d1%:dr%(.)=d2%

NOTE: `133`=kbd:[f1], Image `,`
====

---

### `&,16` sys49152

Perform `sys 49152`.
Usually this is used in a file transfer protocol for performing a file copy, upload, or download.

_Parameters:_

`&,16`[_,sub-function_]

Following `&,16` with a _sub-function_ number (_e.g._, `&,16,2`) calls a sub-function of the module through a _jump table_.

.Details: Jump Tables
****
A _jump table_ is used to give assembly language routines stable entry point addresses that don't change even if routines pointed to change in size.
This is done by maintaining a list of addresses to be ``jmp``ed to in 6510 assembly code.

In other words: when _not_ using a jump table, changing a routine's size shifts subsequent inline routine entry points around by the number of bytes added or subtracted by the modification.
You probably don't want to search for all the BASIC `sys` addresses referencing the changed entry points throughout your code.

Instead, just change the address that the jump table entry ``jmp``s to, and you can keep the BASIC ``sys`` address that calls the routine the same (stable).

As an example, each of these instructions in a fictitious protocol assembly-language jump table starting at ``$c000`` take 3 bytes:

`c000: jmp $c009` ; `sys 49152` sub-function 0 (`&,16`)

`c003: jmp $c0a5` ; `sys 49155` sub-function 1 (`&,16,1`, also the equivalent of `&,17`)

`c006: jmp $c147` ; `sys 49158` sub-function 2 (`&,16,2`)

`c009:` _<first byte of first routine>_ 
****

TIP: Refer to xref:prg-machine-language.adoc#protocols[Protocols] for more information and listings of jump tables.

---

### `&,17` sys49155

Perform `sys 49155` as shown above.

---

### `&,18` Set Screen Mode

This command turns the screen mask on (enabling split screen mode) or off (enabling full-screen mode).
The bottom status line (showing the date and time, status indicators, and the time remaining for a user's call) is always present, regardless of mode.

_Parameters:_

`&,18,0`: Turn the screen mask off, enabling full screen mode (24 lines for viewing caller activity).

`&,18,1`: Turn the screen mask on, enabling split screen mode (16 lines for viewing caller activity).
The 9 lines of the screen mask show:

* the lightbar interface
* system, caller, protocol or network transfer information depending on the BBS's mode
* the modem I/O windows, `M=` free memory, and `L=` BASIC line number currently executing

---

### `&,19` Get Version

This function did something different in Image 1.2, but was removed.
It points to <<get-version,`&,5`: Get Version>> to maintain the numbering of the ``&`` calls.

---

### `&,20` Read from Interface Table [[amp-20-read-from-interface-table]]

// swap3.s

Reads a byte from the interface table.
This is meant to possibly eventually replace ``peek()``ing memory locations.
// position in table is based on frequency of use.
While the functionality is there, it is limited, but can be expanded in the future.

_Parameters:_

`&,20,_index_,_command_`

`index`: position in table (see table)

`command`: [`0`=put in `a%` | `1`=return in accumulator, `peek(780)`]

.Interface Table Addresses [[interface-table-addresses]]
[%autowidth]
[%header]
|====================
| Index | `peek()` | Hexadecimal | Purpose
| 0     | `53252`  | `$d004`     | Input line length
|====================

For now, refer to xref:prg-pokes.adoc#pokes[Pokes and Memory Locations] to see the list of ``poke``s you may use.

---

### `&,21` Write to Interface Table [[amp-21-write-to-interface-table]]

Writes a byte to the interface table.
This is meant to possibly eventually replace ``poke``ing memory locations.
// position in table based on frequency of use.
While the functionality is there, it is limited, but should be expanded in the future.


_Parameters:_

`index`: see <<interface-table-addresses,Interface Table Addresses>> for more information

`value`: the value you would normally `poke` into a memory location

_Example:_

`&,21,0,20` Set input line length to 20 characters.

---

### `&,22` Wait _x_ Tenths of a Second

This waits for any interval from .1 second to 25.5 seconds, in 1/10-second steps.

_Parameters:_

`x`= 1-255

.Example:
// 2.0's i.UD-struct
[source]
----
&,22,10  <1>
&,22,200 <2>
----
<1> Wait 1 second (10 10^ths^ of a second)

<2> Wait 20 seconds (20 10/10^ths^ of a second)

---

### `&,23` Get Character from Modem

[source]
----
3000 &,23:c=peek(780):if c<>32 then 3000 <1>
----
<1> Get character from modem.
Save in `c`.
Loop until the caller hits kbd:[Space] [`chr$(32)`].

TIP: `&,23` doesn't stop and wait for input, unlike the `£g1` MCI command.
If no character is received from the connected user, `peek(780)=0`.

// 1.2 docs say $fe

// asynchronous
// 1. A process in a multitasking system whose execution can proceed independently, "in the background". Other processes may be started before the asynchronous process has finished.

---

### `&,24` xchrout1

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

This is an output character routine that should be used when writing ML routines which need to output a character to the user.

---

### `&,25` Sound

Produce 4 separate sounds, optionally repeating the sound a specified number of times.

_Parameters:_

`&,25,_sound_[,_repeat_]`

_sound_=

	&,25,0  beep
	&,25,1	ding
	&,25,2	higher pitched ding
	&,25,3	gong sound from CCGMS (a terminal program)

`repeat=`
Number of times to repeat: [`0`: Stop repeat | `1-254`: Repeat count | `255`: infinite]

### `&,26` ecschk

====
NOTE: This is currently being researched.
====

---

### `&,27` Save Variable Pointers [[save-variable-pointers]]

This saves pointers that tell BASIC where variables and arrays start and end.
When modules introduce arrays not already defined in `im`, the variable pointers can be restored with `&,28`.
This erases unnecessary variables after they're done being used.

#FIXME#

#### Creating New Arrays

If you define any new arrays in a module, be sure not to consume unnecessary memory after you end the module.
You can do this by using the `&,27` (array pointer save) and `&,28` (array pointer restore) calls.

====
Image 1.2 had just one level of variable pointer save and restore.
Image 1.3 and above adds multiple levels of save and restore with an additional parameter.
// Reflections: 2.0 Facts vs. Fiction
====

[source]
----
3000 &,27,2 <1>
3002 dim u%(10,20) <2>
...
3010 &,28,2:goto 300 <3>
----
<1> save current variable pointers, and create variable pointer level 2

<2> create new array

<3> `&,28,2`: restore level 2 array pointers (this frees up memory used by the array but preserves level 1 system variables still needed by the BBS). `goto 300`: go to main prompt.

#TODO#: I would like a diagram of array pointers, creating new arrays, restoring old pointers here.

====
TIP: The main prompt restores level 1 array pointers and already does a `&,28,1` there.

If you substitute `&,27,1` for `&,27,2` and `&,28,1` for `&,28,2` in the above code, line 300 will redo `&,28,1`.
This causes a `?redim'd array&nbsp;&nbsp;error in 306` (_i.e._, redimensioned array error; an array can't be ``dim``ensioned twice).
====

---

### `&,28` Restore Variable Pointers [[restore-variable-pointers]]

#FIXME#

// array pointers: $13D0-$13DF, is that 16 1-byte pointers (levels 0-15) or 8 2-byte pointers (levels 0-7)?

---

:function_count: 8
include::includes/prg-ml-function-warning.adoc[]

### `&,29` usevar

Get contents of a variable.
This is the routine to call to read the value of a variable from ML.

_Prerequisite:_

`ldx` _variable_number_ ; variable to access.

(Refer to variable table #FIXME#.)

_Returns:_

`$61`: Start of buffer holding the variable contents.

---

### `&,30` putvar

Assign a value to a variable.
This stores the contents of the buffer at `$61` into a variable.

_Prerequisite:_

`ldx` _variable_number_ ; variable to access.

(Refer to variable table #FIXME#.)

_Returns:_

`$61`: Start of buffer holding the variable contents.

---

### `&,31` zero

This stores the floating point equivalent of `0` in the buffer starting at `$61`.

---

### `&,32` minusone

This stores the floating point equivalent of `-1` in the buffer starting at `$61`.

---

### `&,33` getarr

Get descriptor (length and pointer) for an element of `tt$(x)`.

_Prerequisite:_

`ldx` _element_ ; element to access.

_Returns:_ `$61`: Start of buffer holding the descriptor.

---

### `&,34` putarr

---

### `&,35` getln

---

### `&,36` putln

---

###	`&,37` trapon

Enable error-trap routine.
BASIC run-time errors will be caught, and redirected to the BBS error handler at line 2000.

---

###	`&,38` trapoff

Disable error-trap routine.
BASIC run-time errors will not be caught, and will crash like in regular BASIC, halting the program and putting you back at the `ready.` prompt.

---

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

### `&,39` prtln

Prints the array element `tt$()` contained in the `.x` register.

---

###	`&,40` forcegc

Perform a garbage collection (freeing RAM by erasing unused strings).
While the garbage collection is being performed, `G` shows in the status indicator area on the bottom status line.

kbd:[FG] also performs garbage collection if you are in pseudo-local mode.

---

###	`&,41` setbaud

This command changes the _bits per second_ (BPS) rate.

====
NOTE: Do not change the BPS rate while someone is online.
This only changes the rate of Image BBS transmitting data; the modem cannot match speeds except while offline.
====

_Parameters:_

[%header]
[%autowidth]
|===
|Parameter | BPS rate
| `&,41,0` | 300
| `&,41,1` | _not used_
| `&,41,2` | 1200
| `&,41,3` | 2400
| `&,41,4` | 4800
| `&,41,5` | 9600
| `&,41,6` | 19200
| `&,41,7` | 38400
|===

====
TIP: To utilize speeds higher than 2400 BPS, you must have a SwiftLink, Turbo232 or compatible high-speed RS232 cartridge connected to the expansion/cartridge port of your Commodore 64.
====

---

### `&,42` ECS Commands

This group of commands are used for interfacing the Extended Command Set (ECS) with BASIC.
There are sub-commands to:

* load and save the command set
* search for and update individual commands
* `goto` or `gosub` line numbers in `im`, or modules

#### `&,42` Check for ECS Command

This checks whether the command passed in `an$` is a valid ECS command.

_Example:_

.im
 226 f4=.:a%=zz:b%=2^ac%:&,42:if a% then ef$=b$:ep$=a$:ec=a%:ec%=b%:goto 261

_BASIC Setup:_

`an$`: command the user typed

`a%`: Local Mode flag (`zz`)

`b%`: access level

_Returns:_

`a%`: [`0`: not found in ECS table | `_n_`: ECS command #`n`]

`a$`: password

`b$`: ECS flags

// not sure on this
`b%`: credits to use command

---

#### `&,42,1` Goto Line in ECS Command

This will `goto` a particular line in `im` contained in the ECS command, if its `goto/gosub` flag is set to `goto`.
In this respect, it is similar to `&,66`: `calculated GOTO`.

_Parameter:_

`a%`: line number to `goto`

_Example:_

.im
 268 a%=asc(ef$+nl$)+256*asc(mid$(ef$,2,1)+nl$):&,42,1

From an ECS flags string `ef$`, `a%` holds the line # to `goto`, using `&,42,1`.

---

#### `&,42,2` Get ECS Definitions From RAM

_Example:_

.i/IM.ecs
 4004 &,42,2:n=a%:goto 4034

_Returns:_

`a%`: number of ECS definitions in memory

---

#### `&,42,3` Put ECS Definition Into RAM

Add/replace the ECS definition in `tt$(_n_)` to the list currently in memory.

_Parameter:_

`tt$(_n_)`: command definition

`&,42,3,_number_`: the command number in the ECS to add/replace

_Examples:_

.i/IM.ecs
 4010 tt$(n+1)=chr$(0):&,42,3,n+1:return

`n`: the current count of ECS commands

Assign an empty command [`chr$(0)` is a null byte] to the next command [`tt$(n+1)`].

`&,42,3,n+1`: Add the empty command in [`tt$(n+1)`] to the ECS.

---

#### `&,42,4` Load ECS Definitions from Disk

Load ECS definitions from a disk file.

_Parameters:_

`a$`: filename

`dv%`: device #

_Example:_

.im
 3106 a$=dr$+"e.ecs.main":&,42,4

Load the ECS definitions in `e.ecs.main` from disk.

---

#### `&,42,5` Save ECS Definitions to Disk

Save ECS definitions to a disk file.

_Parameters:_

`a$`: filename

`dv%`: device #

_BASIC Setup:_

TIP: Line 4016 is the root example, lines 4010 and 4018 are provided for context.

.i.IM/ecs:

[source,basic]
----
4010 tt$(n+1)=chr$(0):&,42,3,n+1:return <1>

4016 &"Save To Disk{f6:2}":gosub 4010:gosub 4018:gosub 19:a$=dr$+a$:&,42,5:tz=0:return <2>

4018 dr=3:a$="e.ecs.main":return <3>
----

<1> Set end of ECS command list.

<2> `gosub 4010`: see callout 1.
`gosub 4018`: see callout 3.
`gosub 19`: scratch existing `e.ecs.main` file.
`&,42,5`: Save ECS definitions to disk.
`tz=0`: Clear "`file modified`" flag.

<3> assign `dr=3` (Image drive) to the Etcetera disk, and `a$="e.ecs.main"`, the ECS filename.

---

:function_count: 9
include::includes/prg-ml-function-warning.adoc[]

### `&,43` chatchk

Checks for presence of the `Cht` left check mark.

---

### `&,44` trace

Checks for presence of the `Trc` left check mark.

---

### `&,45` prtvar

Prints a variable with MCI enabled.

---

### `&,46` prtvar0

Prints a variable with MCI disabled.

---

### `&,47` carchk

Checks for the presence of a Carrier Detect signal.

_Returns:_

`0`: carrier present, or local mode

`1`: carrier dropped

`2`: timeout

---

### `&,48` getkbd

// this worked converting Lightcycles for Todd Gibson
Check console keyboard for a keypress.
This can also be also used from BASIC.

_Returns:_

`peek(198)`: Character typed

TIP: `&,48` does not stop and wait for input, unlike the `£g1` MCI command.
If no character is typed on the keyboard, `peek(198)=0`.

#FIXME#: verify this

---

### `&,49` getmod

Gets a character from the modem, with ASCII translation.

---

### `&,50` outscn

Output a character to the BBS console.

---

### `&,51` outmod

Outputs character in accumulator [`peek(780)`] to modem.

---

### `&,52` Lightbar Interface

This is how to read the status of lightbar checkmarks, change checkmarks`' status, and move the "`lit`" portion to a specific location.

_Parameters:_

`&,52,_position_,_option_`

====
TIP: `&,52,$_hexadecimal_,_option_` is allowed.

_Example_: Turn off `Trc` left: `&,52,$18,0` (`&,52,24,0` decimal).
====

`option=0`: clear checkmark at _position_

`option=1`: set checkmark at _position_

`option=2`: toggle checkmark at _position_

`option=3`: read status of _position_, return in `a%` (`0`=off, `1`=on)

`option=4`: move lightbar to _position_

Option 5 does the same thing in ML as option 4 does in BASIC.

---

### `&,53` Logoff

:function_count: 1
include::includes/prg-ml-function-warning.adoc[]

* Resets various flags:
** chat page counter
** sound repeat counter
* clears status line indicators

_Example:_

.im:

 3074 &,53

---

### `&,54` Text Editor Interface

// Larry's work, edited for clarity
The text editor is called with the `&,54,_mode_` command.
The editor can be entered in different ways, depending on the value of _mode_.

Line 60100 of `sub.editor` uses `&,54,a`.
The values of _a_ and the purpose for entering the editor are as follows:

.Text editor calls
[%autowidth]
[%header]
[cols="<,^,<"]
|====================
| Line | Variable | Purpose
| `60086` | `a=0` | Normal entry, empty buffer
| `60110` | `a=1` | Buffer not cleared
| `60108` | `a=2` | Extended editor command
|====================

When `a` is equal to 0, this is the "normal" entry point into the editor with an empty buffer.

When `a` is equal to 1, entry into the editor does not clear the buffer.

When `a` is equal to 2, entry into the editor is the point that would be used in an extended command if the command that was typed was not a recognized command.

How to use the editor in your BASIC programs is described later in "`The Editor.`"

////
&,54,0	don't preserve text in tt$() array
&,54,1	re-enter main
&,54,2	re-enter, not command
////

---

:function_count: 2
include::includes/prg-ml-function-warning.adoc[]

### `&,55` output

---

### `&,56` chatmode

---

### `&,57` relread

Reads records from an open RELative file until the character `^` is encountered.

_Parameters:_

`&,57,_lfn_`

`lfn`: logical file number

---

###	`&,58` setalarm

_Parameters:_

`&,58,_hour_,_minute_`

`hour`: hour

`minute`: minute

---

###	`&,59` farerr

Cause a specified BASIC error to happen.

_Parameter:_

`&,59,1,_error_`

_Example:_

 &,59,1,14

Cause error `14`, `?illegal quantity&nbsp;&nbsp;error`.

.Error Numbers
[%header]
[%autowidth]
|===
| Number | Error | Number | Error
| 1 | TOO MANY FILES        |16 | OUT OF MEMORY
| 2 | FILE OPEN             |17 | UNDEF'D STATEMENT
| 3 | FILE NOT OPEN         |18 | BAD SUBSCRIPT
| 4 | FILE NOT FOUND        |19 | REDIM'D ARRAY
| 5 | DEVICE NOT PRESENT    |20 | DIVISION BY ZERO
| 6 | NOT INPUT FILE        |21 | ILLEGAL DIRECT
| 7 | NOT OUTPUT FILE       |22 | TYPE MISMATCH
| 8 | MISSING FILE NAME     |23 | STRING TOO LONG
| 9 | ILLEGAL DEVICE NUMBER |24 | FILE DATA
|10 | NEXT WITHOUT FOR      |25 | FORMULA TOO COMPLEX
|11 | SYNTAX                |26 | CAN'T CONTINUE
|12 | RETURN WITHOUT GOSUB  |27 | UNDEF'D FUNCTION
|13 | OUT OF DATA           |28 | VERIFY
|14 | ILLEGAL QUANTITY      |29 | LOAD
|15 | OVERFLOW              |30 | BREAK
|===

---

### `&,60` Structures

Structures (or _structs_ for short) allow you to access and manipulate the memory used by arrays at machine language speeds.

See the xref:prg-structures.adoc#structures[Structures] chapter for more information.

////
[Ray: &,60 handles X=0,1,2,3,14,15, any other x calls &,68]
////

---

###	`&,61` poscrsr

Move the terminal cursor to a specified column and row on the screen.

_Parameters:_

`&,61,_column_,_row_`

====
NOTE: `0,0` is the top left corner of the screen.
====

.im
[source,basic]
4004 &,38:&,61,.,8:print"&,37:goto300:":end

`&,61,0,8`: position the cursor at column 0, row 9. `print` recovery information if the BBS crashes.

// what is the difference between &,61 and &,70?

---

### `&,62` Set Time

Set BBS clock.

// CIA timer?

_Parameters:_

`&,62,` _hour_, _minute_

`hour`: hour

`minute`: minute

_Example:_

.im:
[source,basic]
3182 &,62,h,m

---

:function_count: 3

include::includes/prg-ml-function-warning.adoc[]

### `&,63` inline1

---

### `&,64` convstr

---

### `&,65` convert

---

### `&,66` Calculated `goto`

`goto` line number held in `a%`.
If you have 13 4-digit `goto` targets on a line, this can save a fair amount of RAM (and BASIC interpretation time).

_BASIC Setup:_

`a%`: line number to `goto`

Instead of writing this (which uses 73 bytes):

[NOTE]
====
Spaces between line number targets have been added for clarity's sake.
====

.Calculated GOTO
====
[source,basic]
on a% goto 3000, 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900, 4000, 4100, 4200, 4300
====



The same thing can be written like so (which uses 19 bytes):

[source,basic]
a%=3000+a%*100:&,66

Based on the value of `a%` (including `0`), `&,66` will `goto` lines starting at 3300 in increments of 100 (`0`=3000, `1`=3100, `2`=3200, `3`=3300, etc.)

// [3000 + (3 &times; 100)].
////
fora=0to3:?a,3000+a*100:next
 0         3000
 1         3100
 2         3200
 3         3300
////

---

### `&,66,1` Calculated `gosub`

`gosub` line number held in `a%`.
If you have 13 4-digit `gosub` targets on a line, this can save a fair amount of RAM (and BASIC interpretation time).

_Example:_

Instead of writing this (which uses 73 bytes):

[source,basic]
on a% gosub 3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,4200,4300

The same thing can be written like so (which uses 38 bytes):

[source,basic]
a%=abs(val(an$)):if a%<15 then a%=3100+a%*50:&,66,1

////
fora=0to3:?a,3100+a*50:next
 0         3100
 1         3150
 2         3200
 3         3250
////

Based on the value of `a%` (including `0`), `&,66,1` will `gosub` lines starting at `3100`, in increments of 50 (`0`=3100, `1`=3150, `2`=3200, `3`=3250, etc).

[source,basic]
a%=3:a%=3100+a%*50:&,66,1

would `gosub 3250`.

---

### `&,67` copyrite

---

### `&,68` struct

// Ray:

Certain sub-functions of `&,60` are re-directed here.

---

### `&,69` Display String on Console

NOTE: This function will not draw PETSCII graphics characters properly.

_Parameters:_

`&,69,_column_,_row_,_text_,_color_`

`column`: `0-39`

`row`: `0-24`

====
NOTE: Upper left of the screen starts at column 0, row 0.
====

`text`: can be a string (`a$`), literal text (`"Hi there!"`), or a combination of both (`"Hi there, "+a$+"!"`)

// not sure MCI commands can be included

`color`: is `1-15` for un-reversed colors.
(`0`, black, is excluded--this is the same numbering as MCI colors.)

For reversed colors, add `$80` (or `128` decimal).
`$8x` is reverse color _x_ (`$81` or `129` is reverse white, `$8f` or `142` is reverse light gray).

_Example:_

.im
[source,basic]
13 &,69,4,21,left$(" "+cm$+"{21 spaces}",22),$8c

[start=1]
. `&,69,4,21`: position string at column 5, row 22

[start=2]
. `left$(" "+cm$+"{21 spaces}",22)`: format the string so it`'s left-justified in the 22-character `Area` window

[start=3]
. `,$8c`: draws the string in reverse (`$8`) in color `$c` (decimal 13, light green)

====
TIP: The module `sub.display` is a good example of using `&,69`.
====

// Will this plot stuff to the screen mask area when in full screen mode? I'm pretty sure it does.

// [[70-position-cursor]] does not work

### `&,70` Position Terminal Cursor [[position-cursor]]

_Parameters_:

`&,70,_column_,_row_`

====
TIP: Upper left corner of the screen is `0,0`.
====

`column`: 0-39

`row`: 0-24

.i.IM
[source,basic]
3350 ... &,70,.,n/2+8.5:&"{white}"

// What is the difference between `&,61 (poscrsr)` and `&,70 (cursposn)`?
