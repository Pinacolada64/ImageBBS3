:toc: left

// https://github.com/Pinacolada64/ImageBBS/blob/534f39f7cbe3f8c896725bc1db94fa23416ecacf/v2/docs/%26%20commands.txt

## Static Arrays (Structures)

_Structures_ allow you to store multiple types of data into memory reserved for arrays, and perform operations on these blocks of memory.
There are functions to:

* put and get strings
* manipulate Image-formatted 11-digit dates
* sort and filter structures
* collect information from structures and put it in another array
* load and save structures

#FIXME: more functions#

String data can be stored in a floating point or integer array.

_Elements_ are the individual "`boxes`" in the array that data is held in.
Let's write a BASIC program to fill and display the elements of an integer array, and then we'll show how to refer to the elements:

.Sample Array
#TODO: finish this#
```
10 print
20 end
```

.Representation of Sample Array
[%autowidth]
|===
| `x%(0,0)` | `x%(0,1)` | `x%(0,2)`
| `x%(1,0)` | `x%(1,1)` | `x%(1,2)`
| `x%(2,0)` | `x%(2,1)` | `x%(2,2)`
|===


It is suggested that you use numeric type arrays, since this will allow you to access the elements as numeric data, as well as put and get strings.

// TODO: can you use string arrays?

Floating point arrays (like `a()` or `b()`) use 5 bytes per element.
Integer arrays (like `a%()` or `b%()`) use 2 bytes per element.
When deciding to use structures, you should determine what types of data you will need to store, and how much memory that data will require.

As an example, let`'s design a structure to hold a user’s handle, ID#, and password.
The handle requires 20 characters.
The ID is an integer type (never > 32767) requiring 2 bytes.
The password is 15 characters.

Since the integers store in 2 bytes, the total number of bytes needed is 37.
Thirty-seven bytes would require 190 integer elements (38 bytes), _or_ 8 floating point elements (40 bytes).
Since the ID# is an integer anyway, it would be best to use the integer array.
The definition would look like this:

 dim u%(18)

TIP: Remember that arrays start at element 0!
 
Of course, you may want to store more than one of these structures in memory.
To do so, you would need a 2-dimensional array.  This would change the `dim` statement to:

 dim u%(18,x-1)

(Suppose that _x_ is the number of structures you want.)

Now that you have the basic concept of the structure, let’s look in a little more detail.
Here is a byte-by-byte map of the structure we designed.

[%header]
[%autowidth]
.Sample structure layout
|===
| Element Position | Byte Position | Data | Type | Bytes Used
| Element 0 | Bytes 00-01 | ID# | Integer | 2 bytes
| Element 1 | Bytes 02-21 | Handle | String | 20 bytes
| Element 11 | Bytes 22-36 | Password | String | 15 bytes
| Element 18½ | Byte 37 | Unused | N/A| 1 byte
|===

NOTE: Because the unused byte is _not_ on an even element boundary, it cannot be used.

// Ryan added this next bit

To refer to bytes in the structure:

* the first number in the array notation is the _element number_ (like a field of a record in a RELative file)
* the second number is the _byte number_.

TIP: Element number `0` and byte number `0` (_e.g._, `u%(0,0)` is often used to hold the number of elements in the structure.

Now down to the important part: how to use all of this!
The structure system is called with either `&,60,_x_,...` or `&,68,_x_,...`.

There are currently 14 sub-functions supported by the structure routines.
They are documented below.

### Numeric Values and Structures

The array used with structures is either an integer or floating point type.
To put numeric values into--or get numeric values from--a structure requires no special structure calls.

// Is this supported?
// If you are using string arrays, 
You may use code similar to the following examples:

.Get number from and put number into structure
[%header]
[%autowidth]
|===
| Get value | Put value
| `f=a%(3,3)` | `a%(3,3)=20`

//| `f` | `a$(3,3)=str$(20)`

|===

TIP: Integer arrays can store values from `-32767` to `32768`.


---

### Put String

Sub-function `0` copies a string variable into a structure.

.Syntax
`&,60,0,_bytes_,_array()_,_string$_`

_bytes_: how many bytes to request from the structure.

_array()_: the array name assigned to the structure you're reading the string from.

_string$_: the string name to read the structure data into.

.Example
 &,60,0,20,u%(1,1),na$

[start=1]
. Put a string:

`**&,60,0**,20,u%(1,1),na$`

[start=2]
. of 20 bytes:

`&,60,0,**20**,u%(1,1),na$`

[start=3]
. from the `u%()` array (element 1, record 1):

`&,60,0,20,**u%(1,1)**,na$`

[start=4]
. into the string variable `na$`:

`&,60,0,20,u%(11,2),**na$**`

### Get String

Sub-function 1 copies a string from a structure into a string variable.

.Syntax
`&,60,1,_bytes_,_array()_,_string$_`

The parameters _bytes_, _array()_, and _string$_ are the same as `Put String` above.

.Example
 &,60,1,20,u%(11,2),a$

[start=1]
. Get a string

`**&,60,1**,20,u%(11,2),a$`

[start=2]
. of 20 bytes

`&,60,1,**20**,u%(11,2),a$`

[start=3]
. from array `u%` (element 11, byte 2)

`&,60,1,20,**u%(11,2)**,a$`

[start=4]
. into `a$`.

`&,60,1,20,u%(11,2),**a$**`

====
In our earlier example user data structure, to access the third user’s password, you would:

[start=1]
. get a string:

`**&,60,1**,20,u%(11,2),a$`

[start=2]
. of 20 bytes:

`&,60,1,**20**,u%(11,2),a$`

[start=3]
. from the `u%` array (element 11, byte 2):

`&,60,1,20,**u%(11,2)**,a$`

[start=4]
. into the string variable `a$`:

`&,60,1,20,u%(11,2),**a$**`

====

### Load structure from disk

Sub-function 2 loads the specified structure on disk into an array.

.Syntax
`&,60,2,0,_array()_,_filename$_,_device_`

.Example
 &,60,2,0,u%(0,0),dr$+"u.handles",dv%

NOTE: You do not have to load the file at the start of the array.

// The starting element is specified in the command.  The example loads the file `u.handles` into the `u%()` array, starting at the beginning of the array.

`**&,60,2,0,**u%(0,0),dr$+"u.handles",dv%`

[start=1]
. Load a structure:

`**&,60,2,0**,u%(0,0),dr$+"u.handles",dv%`

NOTE: The `0` is believed to be a necessary but ignored parameter.

[start=2]
. Use the `u%()` array(element 0, byte 0):

`&,60,2,0,**u%(0,0)**,dr$+"u.handles",dv%`

[start=3]
. Use the drive prefix `dr$`, plus the fictitious `"u.handles"` filename:

`&,60,2,0,u%(0,0),**dr$+"u.handles"**,dv%`

[start=4]
. `dv%` is the device number to load the structure from: 

`&,60,2,0,u%(0,0),dr$+"u.handles",**dv%**`

### Save a structure to disk

Sub-function 3 saves a structure to a specified disk file.

.Syntax
`&,60,3,0,_array()_,_bytes_,_filename$_,_device_`

The parameters _array()_, _bytes_, and _filename$_ are the same as usual.

_device_ should be gotten with:

 dr=6:gosub 3

.Example
 &,60,3,0,u%(0,0),3*38,dr$+"u.handles",dv%

// The starting element is specified with the array, and the number of bytes should be calculated by the number of bytes per structure, multiplied by the number of structures (38 bytes * 3 structures in the example).

[start=1]
. Save a structure:

`**&,60,3,0**,u%(0,0),3*38,dr$+"u.handles",dv%`

[start=2]
. The starting element is specified with _array()_:

`&,60,3,0,**u%(0,0)**,3*38,dr$+"u.handles",dv%`

[start=3]
. _bytes_: the number of bytes per structure, multiplied by the number of structures (3 structures &times; 38 bytes in the example):

`&,60,3,0,u%(0,0),**3*38**,dr$+"u.handles",dv%`

[start=4]
. drive prefix `dr$` + filename (the theoretical `u.handles`):

`&,60,3,0,u%(0,0),3*38,**dr$+"u.handles"**,dv%`

### Put Date

Put an 11-digit date into a structure (stored in Binary Coded Decimal).

.Syntax
`&,60,4,0,_array(a,b)_,_string$_`

_array(a,b)_: array name(`a`=starting structure, `b`=starting byte)

_string$_: the 11-digit date string

.Example
 an$="10412208234":&,60,4,0,u%(3,0),an$

====

.Details: Binary Coded Decimal

Structs store an 11-digit date in 3 bytes using Binary Coded Decimal (BCD) format.
Two decimal digits are stored per byte, using the high and low _nybbles_ (i.e., two 4-bit halves of an 8-bit number).

 an$="10412208234":&,60,4,0,u%(0,1),an$

[cols="8"]
[%autowidth]
|===
// 4 cells, cols 2-3, 4-5, 6-7 span
>|Element
2+^|`u%(0,1)`
2+^|`u%(0,2)`
2+^|`u%(0,3)`
>|_unused_ 

// 8 cells
>| Binary
^| `%0001&nbsp;%0000`
^| `%0100&nbsp;%0001`
^| `%0010&nbsp;%0010`
^| `%0000&nbsp;%1000`
^| `%0010&nbsp;%0011`
>| `%0100`
>| `%xxxx` 

>| Decimal
>| `1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0`
>| `4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1`
>| `2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2`
>| `0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8`
>| `2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3`
>|  `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4`
>|  `&nbsp;&nbsp;&nbsp;&nbsp;x` 
|===

====

### Get Date

Get an 11-digit date from structure.
The date is stored in Binary Coded Decimal (BCD) format as shown above.

.Syntax
`&,60,5,0,_array(a,b)_,_string$_`

_array(a,b)_: array name(`a`=starting structure, `b`=starting byte)

_string$_: string name

.Example
 &,60,5,0,u%(0,1),an$:&,15:&an$

. `&,60,5,0,u%(0,1),an$`: Get a date from the struct into `an$`.

. `&,15`: convert `an$` into a long date string.

. `&an$`: display the long date string.

### Scan Structures

.Purpose

.Syntax
`&,60,6,_num_,_bits_,_a(a,b)_,_b(a,b)_,_size_,_command_,_test_`

////
The syntax has changed between the comments in the source code and i.UD line 3950
updated:
&,60,6,num,bits,a(a,b),b(a,b),size,com,test

Example:
&,60,6,rn,$80,ud%(0,1),ud%(0,1),60,2,2:c%=a%

ud%(0,1),ud%(0,1) -> reads and puts it back?
////

_num_: # of structures to scan

_bits_: the bits to set if true

_a(a,b)_: starting flags(_element_,_byte_)

_b(a,b)_: starting object(_element_,_byte_)

_size_: size in bytes of struct

_command_: command number:

 0: 2 byte and, <>0
 1: 2 byte and, ==0
 2: 2 byte cmp, <
 3: 2 byte cmp, >=
 4: date cmp, <
 5: date cmp, >=

_test_: the object to test for
(apparently can be either a variable or a number, maybe the array number?)

.Example: `i.UD` from Image 2.0
The following code scans the U/D directory for entries which have an upload date older than `ld$`, (setting `$4f` on ud%(0,1) if the entry matches):

 3950 &,60,6,rn,$4f,ud%(0,1),ud%(3,1),60,4,ld$:b%=a%

//    &,60,6,rn,$80,ud%(0,1),ud%(0,1),60,2,2:c%=a%

_&,60,6_: scan struct

_rn_: record number, how many structures to scan in the directory

_$4f_: `%01001111` in binary, #FIXME# still researching the purpose of this

_ud%(0,1)_: #FIXME#

_ud%(3,1)_: Upload date

_60_: structure size, in bytes

_4_: date comparison, `<` (less than)

_ld$_: last call date (the comparison object).
Can apparently be a string name, or number of an array?

.Returns
`a%`: count of structures that the comparison returns as matching `test`.

`b(a,b)`: the structure containing the comparisons matching `test`.  

### Sort

.Purpose

.Syntax
`&,60,7,0,_a(a,b)_,_start?_`

.Example
// Image 2.0 +/lo/tt maint
 &,60,7,0,a$(p+1,i),n-p

### Scan Numbers

.Purpose

.Syntax
`&,60,8,_num_,_size_,_acs_,_a(a,b)_,_a%(a)_,_start_`

_num_: number of structures to scan

_size_: size of the structure, in bytes

_acs_: access level to filter results by

_a(a,b)_: the structure to scan

_a%(a)_: the structure to put the results in? #FIXME#

_start_: element to start scanning at

.Example
 &,60,8,rn,60,a,ud%(0,1),f%(1),1:f%(0)=a%

.Returns
`a%`: #FIXME#

`a%(a)`: #FIXME#

### Scan Sum

.Purpose

.Syntax
`&,60,9,_num_,_size_,_a(a,b)_`

_num_ number of structures to scan

_size_ size of structure

`a(a,b)` structure(_element_,_byte_) to scan

.Example


.Returns
`a%` #FIXME#

### Copy Structure

.Purpose

.Syntax
`&,60,10,_size_,_a1(a,b)_,_a2(a,b)_`

`size` size of structure

`a1(a,b)` source structure

`a2(a,b)` destination structure

.Example
 4326 if x<>fb%(.,.) then for a=x to fb%(.,.)-1:&,60,10,60,fb%(.,a+1),fb%(.,a):next

Copy structure `a+1` to structure `a` in a loop.

### Scan for String

.Purpose

.Syntax
`&,60,11,_num_,_size_,_op_,_str_,_a1(a,b)_,_a2(b)_,_start_`

_num_

`size` size of structure

`op`

`str`

`a1(a,b)` source structure to scan

`a2(b)` target structure to put results into

`start`

.Example

////
arrays1:
		.text "tbdenACDEFAS"
arrays2:
		.text "TBTDN"
		.byte $80, $80, $80, $80, $80
		.text "CO"

		tT
		bB
		dT
		nN
		A{$80}
		C{$80}
		D{$80}
		E{$80}
		F{$80}
		AC
		SO
////

.Arrays used by `Scan String`
[%header]
[%autowidth]
|===
| Number | Array | Purpose 
|  1 | `tt$()` | editor text array
|  2 | `bb$()` |
|  3 | `dt$()` | 
|  4 | `ed$()` | 
|  5 | `nn$()` | 
|  6 | `a%()`  | 
|  7 | `c%()`  | 
|  8 | `d%()`  | 
|  9 | `e%()`  | 
| 10 | `f%()`  | 
| 11 | `ac%()` | access info
| 12 | `so%()` | subops
|===

### Game Scan

.Purpose

.Syntax

`&,60,12,count,size,a$,a%(a,b),b$`

### Text Read

.Purpose

.Syntax
`&,60,13,number,reclen,scan(),bits,text(),strlen`
