' C64List4_04.exe i.test-convert.lbl -prg -verbose -ovr

' fs driver saves as test-convert2/

' source code: swap2.s, convert
{alpha:alt}
{assign:96	=96	} ' yes/no prompt
{assign:300	=300	} ' main prompt

' encoded f-keys
' can't use "quote", that puts a literal quote mark in the string and breaks strings
{quoter:133=comma	} ' f1
{quoter:134=colon	} ' f3
{quoter:135=quotation	} ' f5
{quoter:136=asterisk	} ' f7
{quoter:137=question	} ' f2
{quoter:138=equal	} ' f4
' simiilarly, "return" is already taken by c64list and puts a literal chr$(13) in the string
'{quoter:139=return	} ' f6
{quoter:140=up_arrow	} ' f8

{:3000}
	s1$="{quotation}Well{comma}{quotation} she said{comma} {quotation}the {asterisk} and {question} are used as wildcards.{quotation}{f6}"
	s2$=qt$+"Well,"+qt$+" she said, "+qt$+"the * and ? are used as wildcards."+qt$+r$
{:3002}
	lp=1:&"[0=convnam, 1=convdsk, 2=convimg, 3=chkspcl]{f6}"
	&"Sub-Function: &,65,{pound}i1":op=int(val(an$))
	if op<0 or op>3 then:&"Out of range.{f6}":goto {:3002}
	lp=1:&"Plaintext: "+s1$
' convert plaintext special characters into Image-encoded function keys?
' &,15,2 already converts special chars to readable symbols
' test s3$ against s1$ (encoded), then s2$ (plaintext)
	an$=s3$:&,65,op:s3$=an$
	lp=1:&"Converted: "+s3$+"{f6}"
{ifdef:use_this}
	ct=.:for x=1 to len(s3$):ct=ct+1
' i%: index, ct=counter
	i%=ct:a=-(ct=1 or ct=11 or ct=21 or ct=31):if a=. then {:skip_header}

	&"Pos ":j%=i%:for j=j% to j%+10:&"{pound}#2{pound}#0{pound}%j ":next:&"{f6}"

' Pos 01 02 03 04 05 06 07 08 09 10
' s1$ xx xx xx xx xx xx xx xx xx xx
' s2$ xx xx xx xx xx xx xx xx xx xx
' etc.
	if a then:&"FIXME"
	next
{endif}
	lp=1:&"Testing Image-encoded string against &,65,"+str$(op)+":{f6}"
	x$=s1$:gosub {:sub.test_conversion}
	lp=1:&"Testing plaintext string against &,65,"+str$(op)+":{f6}"
	x$=s2$:gosub {:sub.test_conversion}

	&"Run again?: ":gosub 96:if a then {:3000}
	goto 300

{:sub.test_conversion}
' format string: 3 digits, leading spaces
' tests out a PRG assumption

'  x$ is either of the original strings, encoded or plaintext, per subroutine call
' s3$ is the string converted with &,65,op
	f$="{pound}#3{pound}# "
	for ct=1 to len(x$)
	a%=asc(mid$(x$,ct,1)):b%=asc(mid$(s3$,ct,1)):c%=ct
	if a%<>b% then:&"{f6}Mismatch, position {pound}%c{f6}"
	&f$+"{pound}%c: "+f$+"{pound}%a "+f$+"{pound}%b{f6}"
	next

	&"Strings are ":if x$<>s3$ then:&"not "
	&"equal.{f6}"
	return

' mismatches:
' &,65,0	&,65,1
' 1	135	34
' 6	133	44
' 7	135	34
' 17	133	34
' 19	135	34
' 24
' 30
' 54
' 55
