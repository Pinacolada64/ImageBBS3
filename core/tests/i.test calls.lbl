' C64List4_04.exe "i.test calls.lbl" -crunch -alpha:alt -ovr -prg
' "-crunch:on" must be specified from command-line
' copied from fs driver as "i.test calls.prg"
{crunch:on}	' BUG: doesn't crunch resulting PRG file, must specify "-crunch" on command line
{alpha:alt}

' out-of-module line numbers
{assign:300	=	300} ' main prompt
{assign:370	=	370} ' b$ mode: a

' encoded f-keys
' can't use "quote", that puts a literal quote mark in the string and breaks tokenization
{quoter:133=comma}	' f1
{quoter:135=quotation}	' f5
{quoter:137=question}	' f2
{quoter:140=up_arrow}	' f8

{step:2}

{:3000}
	&"Build date: "+{usedef:__BuildDate}+" "+{usedef:__BuildTime}
' get Trb-L status (db=debug mode):
' 370 inverts a, so pre-inverting it reports actual status
	&,52,$38,3:db=a%:a=1-a%:b$="Debug":gosub 370:&"{pound}q0"
	i$="(investigating)"
' set menu page number, display menu:
	p=1:goto {:menu}

{:sub.input_range}
' on entry:
' m=1: print M)ain Menu option
' q=1: print ?) Help
' l, h: low - high values in range of menu options (e.g., l=0, h=70: 0-70)

' on exit:
' m=1: M)ain menu chosen
' q=1: ?) Help chosen
' an: value of option chosen
' er=1: an is not within the range of l-h
' er=0: it is within the range
	&"[{pound}!l-{pound}!h":if q then:&", {question}) Help"
	if m then:&", M)ain Menu"
' q: quick way of checking for menu/help...
	&"]":p$="Option":&,1:an=int(val(an$)):if q then q=-(an$="{question}")
' ...or main menu input: 'if [q|m] then <whatever>'
	if m then m=-(an$="M")
	er=-(an<l or an>h):if q+m=. then if er then gosub {:sub.out_of_range}
	return

{nice:5}
{:sub.out_of_range}
	&"Out of range.{f6}":return
{:sub.todo}
	&"TODO: Finish this!{f6}":return

{number:3020}
{step:1}
' TODO: gonna need multiple pages (select with "p<x>"?), [+] next page, [-] previous page
' calcgosub example:
'	a%=3000+a%*20:&,66,1:goto {:menu}
{:menu_page_1}
	&" 0) &,0  Output a${f6}"
	&" 1) &,1  Input an${f6}"
	&" 2) &,2  Disk File Input{f6}"
	&" 3) &,3  Read File from Disk{f6}"
	&" 4) &,4  Get Byte from Modem{f6}"
	&" 5) &,5  Get Version{f6}"
	&" 6) &,6  Password Input{f6}"
	&" 7) &,7  Load File{f6}"
	&" 8) &,8  Disk Directory{f6}"
	&" 9) &,9  Bottom Variable{f6}"
	&"10) &,10 Terminal Mode{f6}":return

{:menu_page_2}
{number:3040}
	&"11) &,11 Clear Array{f6}"
	&"12) &,12 New User{f6}"
	&"13) &,13 arbit{f6}"
	&"14) &,14 Dump Array{f6}"
	&"15) &,15 Convert an${f6}"
	&"16) &,16 sys 49152{f6}"
	&"17) &,17 sys 49155{f6}"
	&"18) &,18 Set Screen Mode{f6}"
' TODO: call &,5 routine
	&"19) &,19 Get Version{f6}"
	&"20) &,20 Read from Interface Table{f6}":return

{:menu_page_3}
{number:3060}
	&"21) &,21 Write to Interface Table{f6}"
	&"22) &,22 Delay x Tenths of a Second{f6}"
	&"23) &,23 Get Character from Modem{f6}"
	&"24) &,24 xchrout1{f6}"
	&"25) &,25 Sound{f6}"
	&"26) &,26 callmod{f6}"
	&"27) &,27 Save Variable Pointers{f6}"
	&"28) &,28 Restore Variable Pointers{f6}"
	&"29) &,29 usevar{f6}"
	&"30) &,30 putvar{f6}":return

{:menu_page_4}
{number:3080}
	&"ML Functions:{f6:2}"
	&"31) &,31 zero{f6}"
	&"32) &,32 minusone{f6}"
	&"33) &,33 getarr{f6}"
	&"34) &,34 putarr{f6}"
	&"35) &,35 getln{f6}"
	&"36) &,36 putln{f6}"
	&"37) &,37 trapon{f6}"
	&"38) &,38 trapoff{f6}"
	&"39) &,39 prtln{f6}"
	&"40) &,40 forcegc{f6}":return

{:menu_page_5}
{number:3100}
	&"41) &,41 setbaud{f6}"
	&"42) &,42 ECS Commands{f6}"
	&"[&,43 - &,50 are ML functions]":return

{:menu_page_6}
{number:3120}
	&"[&,51 is an ML function]"
	&"52) &,52 Lightbar Interface{f6}"
	&"53) &,53 Logoff{f6}"
	&"54) &,54 Text editor interface{f6}"
	&"55) &,55 output{f6}"
	&"56) &,56 chatmode{f6}"
	&"57) &,57 relread{f6}"
	&"58) &,58 setalarm{f6}"
	&"59) &,59 farerr{f6}"
	&"60) &,60 Structures  (run {quotation}i.test structs{quotation}){f6}":return

{:menu_page_7}
{number:3140}
	&"61) &,61 poscrsr{f6}"
	&"62) &,62 Set Time{f6}"
	&"63) &,63 inline1{f6}"
	&"64) &,64 convstr{f6}"
	&"65) &,65 convert{f6}"
	&"66) &,66 Calculated goto/gosub{f6}"
	&"67) &,67 copyrite{f6}"
	&"68) &,68 struct (run {quotation}i.test structs{quotation}){f6}"
	&"69) &,69 Display String on Console{f6}"
	&"70) &,70 Position Terminal Cursor{f6}":return

{nice:10}
' 3150?
{:menu}
' display menu page, commands
	a%=3000+p*20:&,66,1:&"{f6}[0-70, Px) Page 1-7, Q)uit, {question}=List]{f6}"
{:prompt}
	l=0:h=70:gosub {:sub.input_range}:on -(an$="Q" or tr%<1) -2*(q=1) goto {:quit}, {:menu}
	if an>15 then:&"& calls 16-70 not finished yet.{f6}":goto {:prompt}
' &,66,1: calcgosub: routines start on 50-line increments
	a%=3200+an*50:&,66,1:goto {:prompt}

{:3200} ' &,0
	&"&,0{f6}":return
{:3250} ' &,1
' TODO: implement &,1,x,<password_mode> flags
	&"&,1{f6}":return
{:3300} ' &,2
	&"&,2{f6}":return
{:3350} ' &,3
	&"&,3{f6}":return
{:3400} ' &,4
	&"&,4{f6}":return
{:3450} ' &,5
	&"&,5{f6}":&,5
' call for &,19 also
' returns:
' lp: major/minor (1.3)
' a%: revision (1)
' a$: date (e.g., "12/29/91  1:18p")
	v=lp:&"Image BBS 64 v{pound}!v.{pound}%a: "+a$+"{f6}"
	return

{:3500} ' &,6
' TODO: test "don't echo chars" &,1,x,y - from Ray's notes
	&"&,6 - password{f6}":return

{:3550} ' &,7
	&"&,7{f6}":return

{:3600} ' &,8
	&"&,8{f6}":return

{:3650} ' &,9
	&"&,9: btmvar{f6}"
' enumerate variables that can be displayed, from &,9,x table:
' 0-9:
	v$="an$a$ b$ tr$d1$d2$d3$d4$d5$ld$"
' 10-19:
	v$=v$+"tt$na$rn$ph$ak$lp pl rc sh mw "
' 20-29:
	v$=v$+"nl ul qe rq ac%ef lf w$ p$ tr%"
' 30-39:
	v$=v$+"a% b$ dv%dr$c1$c2$co$ch$kp%c3$"
' 40-49:
	v$=v$+"f1$f2$f3$f4$f5$f6$f7$f8$mp$mn%"
{:amp_9_help}
' display table row:
' a% a$   b% b$   c% c$   d% d$   e% e$
	for rw=0 to 9
' column indices [must be >=1, mid$() doesn't handle negative values]:
	a%=rw+1:b%=a%+10:c%=b%+10:d%=c%+10:e%=d%+10
' extract row's variable names:
	a$=mid$(v$,a%*3-2,3):b$=mid$(v$,b%*3-2,3):c$=mid$(v$,c%*3-2,3)
	d$=mid$(v$,d%*3-2,3):e$=mid$(v$,e%*3-2,3)
' decrement indices so they display properly (0-49, not 1-50):
	a%=a%-1:b%=b%-1:c%=c%-1:d%=d%-1:e%=e%-1
' display a row:
	&"{pound}#2{pound}# {pound}%a {pound}$a  {pound}#2{pound}# {pound}%b {pound}$b  "
	&"{pound}#2{pound}# {pound}%c {pound}$c  {pound}#2{pound}# {pound}%d {pound}$d  "
	&"{pound}#2{pound}# {pound}%e {pound}$e{f6}":next

{:amp_9_prompt}
	&"{f6}[0-49, A)ll, M)ain Menu, {question}=List]{f6}":p$="Display variable":&,1:op$=an$
	on -(op$="A")-2*(op$="M")-3*(op$="{question}") goto {:amp_9_all}, {:amp_9_quit}, {:amp_9_help}
	an=int(val(op$)):if an<0 or an>49 then gosub {:sub.out_of_range}:goto {:amp_9_prompt}
	gosub {:sub.amp_9_display}:goto {:amp_9_prompt}
{:amp_9_all}
	&"[At {quotation}Key:{quotation} prompt, {quotation}Q{quotation} quits.]{f6}"
	for an=0 to 49:i%=an:&"[#{pound}#2{pound}# {pound}%i/49] "
	gosub {:sub.amp_9_display}:if an$="Q" then:&"Quitting.{f6}":an=50
	next:goto {:amp_9_prompt}
{:sub.amp_9_display}
	&"Displaying "+mid$(v$,(an+1)*3-2,3)
	&,9,an:&" - Key: {pound}g1{f6}":return
{:amp_9_quit}
' restore window to computer type string
' var 36 is co$, computer type:
	&"Restoring window to computer type.":&,9,36:return

{:3700} ' &,10
	&"&,10{f6}":return

{:3750} ' &,11
	&"&,11{f6}":return

{:3800} ' &,12
	&"&,12{f6}":return

{:3850} ' &,13
	&"&,13{f6}":return

{:3900} ' &,14
	&"&,14{f6}":return

{:3950} ' &,15
	&"&,15: convan functions:{f6:2}"
	&"0) &,15   Convert Date{f6}"
	&"1) &,15,1 Title Case{f6}"
	&"2) &,15,2 Decode Function Keys{f6}"
' they both point to same call
	&"3) &,15,3 {pound}$i{f6}"
	&"4) &,15,4 (points to &,15,3){f6}"
	&"5) &,15,5 newdate {pound}$i{f6}"
	&"6) &,15,6 Scan string...{f6}"
{:amp_15_prompt}
	l=0:h=6:m=1:gosub {:sub.input_range}:if m then return
	on an+1 gosub {:sub.todo}, {:sub.todo}, {:sub.todo}, {:sub.todo}, {:sub.todo}, {:15_5}, {:15_6}:goto {:amp_15_prompt}

{:15_5}' &,15,5
	an$="19011038045":gosub {:sub.test_newdate} ' before: sun nov  3, 2090  8:45 pm
	an$="11410288045":gosub {:sub.test_newdate} ' before: sun oct 28, 2014  8:45 pm
	return
{:sub.test_newdate}
	&"{f6}Before: an$={quotation}{$04}{quotation}"+an$:&,15,5:&"{f6} After: an$={quotation}{$04}"+an$+"{quotation}{f6}":return

{:15_6}
' from programmer's reference guide
	&"&,15,6,x: Scan string{f6:2}"
	&"Split String Two Ways [from PRG]:{f6:2}"
	&"1) Scan Using chr$(value){f6}"
	&"2) Scan Using  asc({quotation}char{quotation}){f6:2}"
	&"Other Examples:{f6:2}"
	&"3) Simulate {quotation}instring{quotation} function{f6}"
	&"4) Input scan string/split char{f6:2}"
{:15_6_prompt}
	l=1:h=4:m=1:q=1:gosub {:sub.input_range}
	v$="an$={quotation}Hello world{quotation}:&,15,6,":on an gosub {:sub.15_6_scan_string_chr}, {:sub.15_6_scan_string_asc}, {:sub.todo}, {:sub.todo}
' q="?" entered, m="M"main menu:
	on -(m=1) -2* (q=1) goto {:15_6}, {:15_6_quit}:goto {:15_6_prompt}
{:sub.15_6_scan_string_chr}
' an$="Hello world":&,15,6,32
	&"{pound}$v32{f6}":an$="Hello world":&,15,6,32:gosub {:sub.15_6_results}:return
{:sub.15_6_scan_string_asc}
' an$="Hello world":&,15,6,asc(" ")
	&"{pound}$vasc({quotation} {quotation}){f6}":an$="Hello world":&,15,6,asc(" "):gosub {:sub.15_6_results}:return
{:sub.15_6_results}
' returns a$="Hello", an$="world":
	&"a$={quotation}{pound}$a{quotation}, an$={quotation}{pound}v7{quotation}{f6:2}":return

{:15_6_quit}
	&,28,2:return

' &,57: relread
{nice:10}
{:sub.which_record}
' if er=1, a is out of bounds
	rem for &,57 (relread)
	&"[1-{pound}!t]{f6}":p$="Which Record":&,1:a=int(val(an$)):er=-(a<1 or a>t)
	return

{:sub.load_module}
' TODO: possibly load sub-modules with more functions
	rem sub.load_module

{:quit}
	goto 300
